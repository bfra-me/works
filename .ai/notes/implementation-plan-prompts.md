# Implementation Plan Prompts

This document provides a set of prompts designed to guide AI coding agents in creating implementation plans. The prompts are based on the architectural patterns, service layer design, and development practices established in the project. They can be used as inputs to the `/create-implementation-plan` prompt to generate actionable tasks for agents.

## Implementation Plan Prompts

### [@bfra.me/badge-config Package](../plan/feature-badge-config-package-1.md)
Create a new `@bfra.me/badge-config` package in `packages/badge-config/` following the established monorepo patterns. Implement a TypeScript API for generating shields.io badge URLs with functions like `createBadge({ label, message, color, style })` and preset generators for common badges (build status, coverage, version, etc.). Structure the package with `src/index.ts` as the main export barrel, `src/types.ts` for badge interfaces, and `src/generators/` for specific badge types. Use the fixture-based testing approach with `test/fixtures/input/` containing badge configuration objects and `test/fixtures/output/` containing expected SVG or URL outputs, implementing tests with `it.concurrent()` for parallel execution and `toMatchFileSnapshot()` for comparing generated badge markup. Configure ESLint using `defineConfig()` pattern with TypeScript and Vitest support, create `tsup.config.ts` for ES module builds, extend `@bfra.me/tsconfig/library`, and include comprehensive documentation with usage examples for integration into CI/CD workflows and README files.

### [@bfra.me/create Package Revamp](../plan/refactor-create-cli-redesign-1.md)
Completely redesign `@bfra.me/create` to remove dependency on `@sxzz/create` and transform it into a comprehensive CLI for TypeScript project scaffolding. Research and implement modern template repository patterns using `giget` for fetching remote templates and local folder copying capabilities, replacing the current simple template system with a flexible architecture supporting GitHub repositories, local directories, and URL-based templates. Integrate `@clack/prompts` for interactive CLI experiences with multi-step project configuration, template selection, and customization options. Add AI-powered features for intelligent project setup, dependency recommendations, and code generation using LLM APIs for analyzing project requirements and suggesting optimal configurations. Extend functionality beyond initial project creation to support adding individual components, features, or configuration files to existing projects through commands like `@bfra.me/create add <feature>`. Implement comprehensive fixture-based testing with `test/fixtures/input/` containing various project configurations and `test/fixtures/output/` directories for expected project structures, using `it.concurrent()` and file snapshot testing to validate template generation, CLI interactions, and AI-generated code quality.

### [@bfra.me/works Package Template](../plan/feature-works-package-template-1.md)
Develop a specialized template within the revamped `@bfra.me/create` system specifically for generating new packages within the bfra.me Works monorepo. Create a template structure in `templates/bfra-works-package/` that includes templatable files with variable substitution for package name, description, and functionality type (utility, config, tool). Include a comprehensive `readme.md` template with sections for installation, usage, API reference, and examples that follows the established documentation patterns across existing packages. Implement automated integration workflows that not only generate the package structure in `packages/{{packageName}}/` but also update the documentation site by creating corresponding MDX files in `docs/src/content/docs/packages/{{packageName}}.mdx` with proper frontmatter, navigation integration, and cross-references to the main documentation structure. Include template files for `tsup.config.ts`, `eslint.config.ts`, `tsconfig.json`, and proper `package.json` configuration with workspace dependencies, ensuring the generated package follows all established patterns including fixture-based testing setup and proper export structures.

### @bfra.me/create Package Analysis & Refactoring
Conduct a comprehensive analysis of the `@bfra.me/create` package to identify DRY violations, duplicate functionality between template processing systems, overlapping command logic, and UX pain points in CLI interactions (confusing prompts, inconsistent command patterns, poor error messages), while examining DX issues in the programmatic API (complex class hierarchies, unclear return types, inconsistent error handling). Refactor the codebase from class-based architecture to functional factory patterns using composition over inheritance, implement sophisticated TypeScript typing with branded types for template sources and strict result types, consolidate the `create` command as the primary interface while maintaining `add` as a distinct subcommand, achieve minimum 80% test coverage through comprehensive unit tests for template resolution/processing/AI analysis and integration tests for CLI workflows, and establish consistent command patterns with unified error handling, progress indicators, and validation across all user-facing interfaces.

### @bfra.me/eslint-config Markdown Support Revamp
Completely rewrite the Markdown linting integration in `@bfra.me/eslint-config` to properly leverage `@eslint/markdown` package capabilities, implementing transparent configuration options for GitHub Flavored Markdown (GFM) support, language-specific processing options, and custom parser configurations. Enable TypeScript-ESLint parsing within fenced code blocks by configuring processor chains that extract TypeScript/JavaScript code from Markdown and apply appropriate linting rules, while supporting frontmatter parsing (YAML/TOML), eslint-disable directive handling within Markdown comments, and comprehensive language block processing (TypeScript, JavaScript, JSON, etc.). Develop extensive test suites covering edge cases like nested code blocks, mixed language files, frontmatter variations, and eslint directive interactions, document the configuration API with practical examples for different Markdown use cases (documentation sites, README files, blog posts), and ensure backward compatibility with existing Markdown files across the monorepo while providing migration paths for enhanced features.

### @bfra.me/semantic-release Package Rewrite
Rewrite `@bfra.me/semantic-release` from the ground up to provide comprehensive TypeScript support for semantic-release ecosystem, implementing fully typed configuration objects for global settings and all popular plugins (@semantic-release/changelog, @semantic-release/git, @semantic-release/github, etc.), creating factory functions for JavaScript-based config files (release.config.mjs) with IntelliSense support and runtime validation. Develop a plugin development toolkit with TypeScript interfaces for custom plugin creation, context typing, and lifecycle hooks, implement shareable configuration presets for common workflows (npm packages, GitHub releases, monorepo publishing), and create configuration composition utilities that allow mixing and extending base configurations. Build comprehensive test infrastructure covering plugin integration scenarios, configuration validation, TypeScript compilation checks, and real-world release workflows, while providing detailed documentation with examples for plugin development, preset usage, and advanced configuration patterns that integrate seamlessly with the existing changesets workflow.

### @bfra.me/docs-sync Automated Documentation Engine
Build an intelligent documentation synchronization engine that continuously monitors package source code, README files, and JSDoc comments to automatically update the Astro documentation site with zero manual intervention. Implement AST parsing and content extraction from TypeScript source files to generate API reference documentation, create bidirectional sync capabilities that can update source code examples when documentation changes (using template replacement and validation), and develop intelligent content mapping between package READMEs and corresponding documentation pages. Establish a file watcher system with incremental updates, implement conflict resolution for competing changes, create content validation pipelines that ensure documentation accuracy against actual code behavior, and build a plugin architecture for custom content processors (handling different documentation formats, code example extraction, cross-reference generation). Include comprehensive testing with mock file systems, document generation validation, and integration tests that verify the entire sync pipeline from source changes to deployed documentation updates.

### @bfra.me/config-composer Dynamic Configuration Generator
Develop an intelligent configuration composition system that analyzes project codebases to automatically generate optimized ESLint, Prettier, and TypeScript configurations tailored to detected frameworks, libraries, and coding patterns. Implement AST-based codebase analysis to identify React/Vue/Svelte usage, Node.js/browser targets, testing frameworks, and architectural patterns, then compose configuration rulesets from modular rule groups with intelligent conflict resolution and priority management. Integrate AI-powered configuration suggestions using LLM analysis of code patterns, style preferences, and team conventions, implementing learning capabilities that adapt configurations based on project evolution and developer feedback. Create hot-reload functionality for development environments with configuration change detection, validation, and seamless rule updates, while building a plugin system for custom analyzers and configuration generators. Include comprehensive testing with diverse project scenarios, configuration validation against real codebases, and performance benchmarks for large monorepo analysis.

### @bfra.me/workspace-analyzer Monorepo Intelligence Platform
Create a comprehensive workspace analysis package that performs deep AST parsing and static analysis across the entire monorepo to detect configuration inconsistencies, unused dependencies, circular imports, architectural violations, and performance optimization opportunities. Implement intelligent dependency graph analysis with visual representations, package coupling metrics, and suggestions for dependency consolidation or splitting, while using AI-powered recommendations for refactoring opportunities based on code complexity analysis, import pattern optimization, and architectural best practices. Develop real-time monitoring capabilities with file system watchers, incremental analysis updates, and integration with CI/CD pipelines for automated quality gates and architectural compliance checking. Build sophisticated reporting with interactive dashboards, automated issue prioritization, and actionable remediation suggestions, while creating plugin architecture for custom analyzers and integration with external tools (bundlers, test coverage, performance monitoring). Include comprehensive testing with synthetic monorepo scenarios, performance benchmarks for large codebases, and validation against known architectural patterns and anti-patterns.

### Go-Live Checklist & Production Readiness Validation
Develop a comprehensive production readiness checklist and automated validation system that thoroughly examines all packages for bundling issues (incorrect exports, missing dependencies, bundle size optimization), content completeness (documentation coverage, example validity, README accuracy), deployment configurations (CI/CD pipeline validation, release automation testing, npm publishing verification), runtime error detection (console error scanning, network failure simulation, edge case testing), and cross-environment compatibility (Node.js version support, browser compatibility, package manager compatibility). Implement automated testing suites that validate package installations in clean environments, verify CLI functionality across different operating systems, test API usage patterns in various project configurations, and simulate real-world usage scenarios with error injection and recovery testing. Create reusable validation workflows that can be applied to future package releases, establish quality gates for CI/CD pipelines with automated blocking of problematic releases, and develop monitoring dashboards that track production health metrics, user adoption patterns, and potential issues across the entire package ecosystem.

## Advanced Follow-Up Implementation Prompts

### **Distributed Package Intelligence Network**
Explore creating a federated intelligence system where `@bfra.me/workspace-analyzer` and `@bfra.me/config-composer` share analysis data across different projects and organizations to build collective intelligence about optimal configurations, common patterns, and emerging best practices. Challenge the assumption that configuration should be project-specific by investigating how anonymous usage analytics, pattern recognition, and collaborative filtering could create self-improving configuration recommendations that evolve based on community usage patterns and successful project outcomes.

### **Zero-Configuration Development Paradigm**
Investigate a radical approach to development tooling where `@bfra.me/create`, `@bfra.me/config-composer`, and `@bfra.me/docs-sync` work together to create completely zero-configuration development experiences that automatically adapt to developer intent without explicit configuration files. Challenge the core assumption that developers need to understand and maintain configuration by exploring how AI-driven intent recognition, behavioral pattern analysis, and automated decision-making could eliminate configuration overhead while maintaining flexibility and control when needed.

### **Living Documentation Ecosystem**
Develop an advanced documentation system that goes beyond static sync to create living, interactive documentation that automatically updates code examples, validates tutorial steps, runs integration tests against documentation, and provides real-time feedback to developers. Challenge the assumption that documentation is separate from code by investigating how executable documentation, embedded testing, and bidirectional code-documentation relationships could create self-validating, always-current knowledge systems that serve as both documentation and quality assurance infrastructure.
