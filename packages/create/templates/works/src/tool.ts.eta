<% if (it.packageType === 'tool') { -%>
import type {<%= it.pascalCase(it.packageName) %>ToolOptions, <%= it.pascalCase(it.packageName) %>ToolResult} from './types.js'
import {promises as fs} from 'node:fs'
import path from 'node:path'

/**
 * Main tool functionality for <%= it.capitalizeFirst(it.packageName) %>
 *
 * @param options - Tool configuration options
 * @returns Tool operation result
 *
 * @example
 * ```typescript
 * const result = await run<%= it.pascalCase(it.packageName) %>Tool({
 *   input: './src',
 *   output: './dist',
 *   dryRun: false
 * })
 * console.log(`Processed ${result.files.length} files in ${result.duration}ms`)
 * ```
 */
export async function run<%= it.pascalCase(it.packageName) %>Tool(
  options: <%= it.pascalCase(it.packageName) %>ToolOptions = {}
): Promise<<%= it.pascalCase(it.packageName) %>ToolResult> {
  const startTime = Date.now()
  const warnings: string[] = []
  const files: string[] = []

  try {
    // Validate options
    validate<%= it.pascalCase(it.packageName) %>ToolOptions(options)

    // Process input
    if (options.input) {
      const inputFiles = await discoverFiles(options.input)
      files.push(...inputFiles)

      for (const file of inputFiles) {
        await processFile(file, options, warnings)
      }
    }

    // Handle dry run
    if (options.dryRun) {
      warnings.push('Dry run mode - no files were actually modified')
    }

    const duration = Date.now() - startTime

    return {
      files,
      duration,
      warnings
    }
  } catch (error) {
    const duration = Date.now() - startTime
    throw new Error(`<%= it.capitalizeFirst(it.packageName) %> tool failed after ${duration}ms: ${error}`)
  }
}

/**
 * Validates tool options for <%= it.capitalizeFirst(it.packageName) %>.
 *
 * @param options - Options to validate
 * @throws Error if options are invalid
 */
export function validate<%= it.pascalCase(it.packageName) %>ToolOptions(
  options: <%= it.pascalCase(it.packageName) %>ToolOptions
): void {
  if (options.input && typeof options.input !== 'string') {
    throw new Error('Input option must be a string path')
  }

  if (options.output && typeof options.output !== 'string') {
    throw new Error('Output option must be a string path')
  }

  if (options.dryRun !== undefined && typeof options.dryRun !== 'boolean') {
    throw new Error('DryRun option must be a boolean')
  }
}

/**
 * Discovers files to process from the input path.
 *
 * @internal
 * @param inputPath - Path to discover files from
 * @returns Array of file paths
 */
async function discoverFiles(inputPath: string): Promise<string[]> {
  const files: string[] = []

  try {
    const stat = await fs.stat(inputPath)

    if (stat.isFile()) {
      files.push(inputPath)
    } else if (stat.isDirectory()) {
      const entries = await fs.readdir(inputPath, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(inputPath, entry.name)

        if (entry.isFile()) {
          files.push(fullPath)
        } else if (entry.isDirectory()) {
          const subFiles = await discoverFiles(fullPath)
          files.push(...subFiles)
        }
      }
    }
  } catch (error) {
    throw new Error(`Failed to discover files from ${inputPath}: ${error}`)
  }

  return files
}

/**
 * Processes a single file.
 *
 * @internal
 * @param filePath - Path to the file to process
 * @param options - Processing options
 * @param warnings - Array to collect warnings
 */
async function processFile(
  filePath: string,
  options: <%= it.pascalCase(it.packageName) %>ToolOptions,
  warnings: string[]
): Promise<void> {
  try {
    // Add your file processing logic here
    console.log(`Processing file: ${filePath}`)

    if (options.dryRun) {
      console.log(`Would process: ${filePath}`)
      return
    }

    // Example: Read file content
    const content = await fs.readFile(filePath, 'utf-8')

    // Example: Process content
    const processedContent = content // placeholder - add your logic

    // Example: Write to output if specified
    if (options.output) {
      const relativePath = path.relative(options.input || '', filePath)
      const outputPath = path.join(options.output, relativePath)

      // Ensure output directory exists
      await fs.mkdir(path.dirname(outputPath), { recursive: true })
      await fs.writeFile(outputPath, processedContent, 'utf-8')
    }

  } catch (error) {
    warnings.push(`Failed to process ${filePath}: ${error}`)
  }
}

/**
 * Creates default tool options for <%= it.capitalizeFirst(it.packageName) %>.
 *
 * @param overrides - Option overrides
 * @returns Default options with overrides applied
 */
export function createDefault<%= it.pascalCase(it.packageName) %>ToolOptions(
  overrides: Partial<<%= it.pascalCase(it.packageName) %>ToolOptions> = {}
): <%= it.pascalCase(it.packageName) %>ToolOptions {
  return {
    dryRun: false,
    ...overrides
  }
}
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error))
    }
  }
}<% } %>
