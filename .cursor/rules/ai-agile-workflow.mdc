---
description: FOLLOW when MANAGING tasks to STREAMLINE progress tracking and ENSURE proper memory file management with vibe-tools integration
globs: docs/plans/*.md,docs/tasks/**/*.md,docs/features.md,docs/plan.md,docs/memory/**/*.md
alwaysApply: false
---
# AI-Assisted Agile Workflow

Guidelines for using Cursor rules to generate and track task documents from plan documents.

<rule>
name: ai_agile_workflow
description: Process for generating well-defined task documents from plans and tracking progress using AI assistance
filters:
  - type: file_path
    pattern: "docs/(plans|tasks)/.*\\.md$"
  - type: file_path
    pattern: "docs/features\\.md$"
  - type: file_path
    pattern: "docs/plan\\.md$"
  - type: file_path
    pattern: "docs/memory/.*\\.md$"
  - type: message
    pattern: "(?i)(task generation|plan breakdown|agile workflow|track feature|create task)"
  - type: content
    pattern: "\\[Plan\\]|\\[Task\\]|\\[Status: (Not Started|In Progress|Completed)\\]"

actions:
  - type: suggest
    message: |
      # AI-Assisted Agile Workflow

      This workflow uses Cursor rules and AI assistance to generate well-defined task documents from comprehensive plans and track progress on features.

      ## Overview of the Workflow

      Our AI-assisted agile workflow combines traditional agile methodologies with AI automation to streamline development processes. The workflow consists of:

      1. **Capturing Features** in a central reference document
      2. **Creating Plan Documents** that outline comprehensive implementation approaches
      3. **Generating Task Documents** from plans with AI assistance
      4. **Tracking Progress** with AI-generated reports
      5. **Updating Status** automatically as tasks are completed

      ## Document Types

      *(Note: Placeholders like `[Title]` or `${variable}` in templates should be filled by the AI based on context.)*

      ### 1. Central Reference Document ([features.md](mdc:docs/features.md))

      This document tracks all features for improving the project, including:

      ```markdown
      # Project Features

      ## Current Features

      ### Feature 1: [Title]

      - **Description**: Brief description of the feature
      - **Status**: [Not Started | In Progress | Completed]
      - **Plan Document**: [Link to plan document]
      - **Priority**: [High | Medium | Low]
      - **Created**: YYYY-MM-DD
      - **Updated**: YYYY-MM-DD

      ### Feature 2: [Title]

      ...

      ## Completed Features

      ### Feature X: [Title]

      - **Description**: Brief description of the feature
      - **Status**: Completed
      - **Plan Document**: [Link to plan document]
      - **Completion Date**: YYYY-MM-DD
      - **Outcome**: Brief description of the outcome
      ```

      ### 2. Plan Documents (`docs/plans/[plan-name].md`)

      Each plan document outlines a comprehensive approach to implementing a feature:

      ```markdown
      # Plan: [Plan Title]

      ## Overview

      Brief description of the plan and its goals.

      ## Related Feature

      [Link to the feature in the features document]

      ## Success Criteria

      - Criterion 1
      - Criterion 2
      - ...

      ## Implementation Phases

      ### Phase 1: [Phase Title]

      **Objective**: Clear statement of the phase objective

      **Tasks**:

      1. [Task 1 description]
         - **Complexity**: [Low | Medium | High]
         - **Dependencies**: None
         - **Acceptance Criteria**: Clear criteria for completion

      2. [Task 2 description]
         - **Complexity**: [Low | Medium | High]
         - **Dependencies**: Task 1
         - **Acceptance Criteria**: Clear criteria for completion

      ### Phase 2: [Phase Title]

      ...

      ## Timeline

      - Phase 1: X weeks
      - Phase 2: Y weeks
      - ...

      ## Resources Required

      - Resource 1
      - Resource 2
      - ...
      ```

      ### 3. Task Documents (`docs/tasks/[task-id].md`)

      Individual task documents derived from plan documents:

      ```markdown
      # Task: [Task Title]

      ## Task ID: YYYY-MM-DD-XX

      ## Related Plan

      [Link to the plan document]

      ## Description

      Detailed description of the task.

      ## Acceptance Criteria

      - Criterion 1
      - Criterion 2
      - ...

      ## Dependencies

      - [List of dependencies, if any]

      ## Complexity

      [Low | Medium | High]

      ## Estimated Effort

      [X hours | X days]

      ## Status

      [Not Started | In Progress | Completed]

      ## Assignee

      [Name or "Unassigned"]

      ## Notes

      Any additional notes or context.
      ```

      ### 4. Memory File ([workflow-status.md](mdc:docs/memory/workflow-status.md))

      A memory file that tracks the current state of the workflow and provides context for AI assistants:

      ```markdown
      # Workflow Status Memory

      ## Current State

      - **Current Date**: YYYY-MM-DD
      - **Active Projects**:
        1. [Project 1 name]
        2. [Project 2 name]
      - **Current Plans**:
        1. [Plan 1 name]
        2. [Plan 2 name]
      - **Current Phase**:
        1. [Phase 1 name] ([Project 1 name])
        2. [Phase 2 name] ([Project 2 name])
      - **Active Tasks**:
        - [Task 1 name] (Task ID: YYYY-MM-DD-XX)
        - [Task 2 name] (Task ID: YYYY-MM-DD-XX)
      - **Next Tasks**:
        - [Next task 1 name] (not assigned yet)
        - [Next task 2 name] (Task ID: YYYY-MM-DD-XX)

      ## Task History

      | Task ID | Task Name | Status | Completion Date |
      |---|-----|-----|----|
      | YYYY-MM-DD-XX | [Task name] | [Status] | [Completion date] |

      ## Context

      [Additional context about the current tasks and projects]

      ## Recent Updates

      - [Update 1] (YYYY-MM-DD)
      - [Update 2] (YYYY-MM-DD)

      ## Command History

      ```
      # Recent commands executed as part of the workflow
      [Command 1]
      [Command 2]
      ```

      ## Notes

      - [Note 1]
      - [Note 2]

      ## Updated: YYYY-MM-DD
      ```

      ## Workflow Process

      ### Essential Context Loading

      Before beginning any task in the workflow, you MUST load the following essential memory files into context:

      1. **[workflow-status.md](mdc:docs/memory/workflow-status.md)**: Provides current state of the workflow, active tasks, and recent updates
      2. **[architecture.md](mdc:docs/memory/architecture.md)**: Gives overview of system architecture and components
      3. **[user-preferences.md](mdc:docs/memory/user-preferences.md)**: Details user preferences for code style, tools, and workflow
      4. **[domain-knowledge.md](mdc:docs/memory/domain-knowledge.md)**: Contains domain-specific knowledge and terminology

      Loading these files is MANDATORY at the start of every interaction to ensure you have the necessary context for accurate planning and task execution.

      Always use `Sequential Thinking` to thoroughly analyze these files and extract relevant information for the current task or query.

      ### Sequential Thinking Requirement

      All steps in this workflow MUST utilize the `Sequential Thinking` tool or approach to ensure:
      1. Thorough analysis of each step
      2. Comprehensive planning
      3. Careful consideration of implications
      4. Step-by-step reasoning
      5. Context retention across sessions

      For any complex request or workflow step, use `Sequential Thinking` to break down the process into manageable steps, analyze each thoroughly, and document your reasoning process.

      When you see instructions that say "Use Sequential Thinking," this means you should either:
      1. Use the `mcp_Sequential_Thinking_sequentialthinking` tool when available, OR
      2. Structure your response with explicitly numbered thought steps, showing your reasoning process

      ### Step 1: Capture Features

      #### Feature Definition with Web Research

      Ideally, perform initial research *before* adding a feature to `docs/features.md` to better inform its definition and scope. Use [`vibe-tools web`](mdc:.cursor/rules/vibe-tools.mdc) to conduct comprehensive research and competitor analysis. This ensures that features align with industry best practices and market needs:

      ```bash
      # Research best practices for a feature
      vibe-tools web "Research best practices for implementing semantic versioning in a monorepo structure similar to our project. Focus on automation and integration with existing workflows."

      # Analyze competitor implementations
      vibe-tools web "Compare approaches for implementing cross-references between Markdown files with focus on compatibility with VS Code and Cursor IDE."

      # Research specific technical approaches
      vibe-tools web "What are the current best practices for implementing cross-references in documentation that need to work in both web and IDE environments?"
      ```

      When you have specific URLs or documentation to reference, use the `--with-doc` option to provide more focused context:

      ```bash
      # Research with specific documentation as context
      vibe-tools web "Analyze best practices for rule-based documentation systems" --with-doc="https://example.com/documentation-standards.pdf"

      # Combine multiple documentation sources
      vibe-tools web "Compare our approach with industry standards" --with-doc="https://example.com/standard1.html" --with-doc="https://example.com/standard2.html"
      ```

      After completing your research, proceed with adding features to the central reference document:

      1. Open `docs/features.md`
      2. Add new features with the following structure:
         ```markdown
         ### Feature X: [Title]

         - **Description**: Brief description
         - **Status**: [Not Started]
         - **Plan Document**: Not created yet
         - **Priority**: [High | Medium | Low]
         - **Created**: YYYY-MM-DD
         - **Updated**: YYYY-MM-DD
         ```

      ### Step 2: Create Plan Documents

      1. For high-priority features, create a plan document in `docs/plans/`
      2. Use the following prompt with the AI:
         ```
         Create a plan document for implementing [feature title]
         ```
      3. The AI will generate a structured plan based on the feature
      4. Review and refine the plan as needed

      #### Planning with Vibe-Tools

      For more comprehensive planning with context-aware AI assistance, use `vibe-tools plan`. This approach ensures plans consider repository structure, related components, and implementation patterns:

      ```bash
      # Generate comprehensive implementation plan
      vibe-tools plan "Create a detailed implementation plan for adding cross-referencing capabilities to Cursor rules. Include phases, tasks, acceptance criteria and estimated story points."

      # Create plan with specific focus areas
      vibe-tools plan "Generate implementation plan for memory file automation with focus on maintaining strict formatting according to memory-management guidelines. Identify required updates to ai-agile-workflow.mdc."

      # Generate task breakdown within a plan
      vibe-tools plan "Break down the vibe-tools integration phase into discrete, estimable tasks with dependencies."
      ```

      When creating plans that involve memory file updates, always include memory formatting context in your prompts to ensure the AI has the necessary guidelines:

      ```bash
      # Plan with memory formatting context
      vibe-tools plan "Create implementation plan for feature X that includes memory file update steps. Include details on proper memory file formatting per memory-management.mdc, specifically:
      - Always search for existing sections before adding new ones
      - Merge content into existing sections rather than creating duplicates
      - Keep the 'Updated: YYYY-MM-DD' line as the very last line
      - Use proper section merging for lists, tables, and text
      - Follow the date-consistency-enforcer rule for obtaining dates"
      ```

      For plans that require specific documentation context, use the `--with-doc` option:

      ```bash
      # Include memory-management.mdc guidelines directly
      vibe-tools plan "Plan implementation for feature X with memory file updates" --with-doc="https://raw.githubusercontent.com/bfra-me/works/main/.cursor/rules/memory-management.mdc"
      ```

      After generating the plan, save it to the appropriate location in the `docs/plans/` directory with a descriptive name.

      ### Step 3: Generate Task Documents

      When you have a plan document open, ask the AI to generate task documents:

      ```
      Generate task documents from this plan
      ```

      **Before creating a new task document, you MUST check the `docs/tasks/` and `docs/tasks/done/` directories for existing task files for the current date (e.g., using `list_dir` tool). Use the next available sequence number (e.g., if `2025-05-02-01.md` exists, the next should be `2025-05-02-02.md`). Never overwrite an existing task file.**

      For more structured and context-aware task breakdown, leverage `vibe-tools`:

      #### Task Generation with Vibe-Tools

      Using `vibe-tools` can provide more context-aware and structured task generation:

      - **Using `vibe-tools plan` for Task Breakdown:**
        `vibe-tools plan` can analyze a feature's objectives or a plan document to automatically suggest a breakdown into specific tasks.
        ```bash
        # Example: Break down a feature specified in a plan document
        vibe-tools plan "From the plan in docs/plans/my-feature-plan.md, generate actionable tasks for the frontend implementation phase."

        # Example: Save output directly to a task file (useful for initial task creation)
        vibe-tools plan "Break down the 'User Authentication' feature into tasks" --save-to docs/tasks/$(date +%Y-%m-%d)-01.md
        ```
        *(Ensure the date command usage aligns with `date-consistency-enforcer.mdc` if used directly in rules, or prefer AI to generate full task IDs.)*

      - **Using `vibe-tools repo` for Code-Aware Task Definition:**
        `vibe-tools repo` offers contextual insights by leveraging the existing repository structure, helping to define tasks based on current code.
        ```bash
        # Example: Define tasks based on codebase structure for a refactoring effort
        vibe-tools repo "For the refactoring plan of the 'SettingsModule', identify tasks needed to update its dependencies in 'ProfileComponent' and 'AdminPanel'."

        # Example: Break down implementation based on current rule structures
        vibe-tools repo "Break down the implementation of cross-references into discrete tasks based on the current structure of Cursor rules. Consider file paths, parsing requirements, and rendering approaches."
        ```
      These commands ensure that task generation is informed by both the broader feature context and the specific details of the codebase.
      Refer to [vibe-tools](mdc:.cursor/rules/vibe-tools.mdc) for more command details.

      For more structured and context-aware task breakdown, use `vibe-tools plan`:
      ```bash
      # Generate task breakdown from plan
      vibe-tools plan "Break down this plan into specific tasks with complexity, dependencies, and acceptance criteria: [paste relevant part of plan here]"

      # Generate tasks with memory update requirements
      vibe-tools plan "Create task documents for implementing feature X. Include steps for proper memory file updates following memory-management.mdc guidelines. Each task should specify which memory files to update and how to maintain formatting integrity."

      # Save tasks directly to task files
      vibe-tools plan "Break down feature X implementation into tasks" --save-to task-breakdown.md
      ```

      When generating tasks that involve memory file updates, always include explicit memory formatting instructions to external AI assistants:

      ```bash
      # Template for memory file update request with formatting context
      MEMORY_INFO="Information to update in the memory file"
      vibe-tools ask "Update the workflow-status.md memory file with the following information:\n$MEMORY_INFO\n\nFOLLOW THESE EXACT FORMATTING REQUIREMENTS:\n1. Maintain all existing sections and their order\n2. Search for existing sections before adding new ones\n3. Merge content into existing sections rather than creating duplicates\n4. Keep the 'Updated: YYYY-MM-DD' line as the very last line in the file\n5. Use this exact date format: YYYY-MM-DD (e.g., 2025-05-06)\n6. Format tables and lists precisely as shown in memory-management.mdc\n7. Never create duplicate sections or multiple timestamp lines\n\nEXAMPLE OF CORRECT FORMATTING:\n\`\`\`markdown\n# Section Name\n\n## Subsection\n- Item 1\n- Item 2\n\n## Another Subsection\n| Column 1 | Column 2 |\n|----|----|\n| Value 1  | Value 2  |\n\n## Updated: 2025-05-06\n\`\`\`" # AI Assistant should replace this with actual command to save to file or update memory
      ```

      The AI will:
      1. Extract tasks from each phase
      2. Create individual task documents in `docs/tasks/`
      3. Name them with a pattern: `YYYY-MM-DD-XX.md` (e.g., `2025-05-06-01.md`). Obtain the date following [date-consistency-enforcer](mdc:.cursor/rules/date-consistency-enforcer.mdc), prefer `mcp_time_get_current_time` tool, fallback to `$(date +%Y-%m-%d)-XX.md`.
      4. Include all necessary details from the plan
      5. Update the memory file with new task information
      6. Update the plan document

      ### Step 4: Execute Tasks

      1. Prioritize tasks based on dependencies and complexity
      2. Assign tasks to team members
      3. Update task status as work progresses:
         - [Not Started]
         - [In Progress]
         - [Completed]

      **Note on Task Documentation**: Keep task-specific notes, analyses, checklists, or findings directly within the corresponding task file (`docs/tasks/[task-id].md`) under appropriate headings (e.g., "## Task Analysis", "## Implementation Notes", "## Audit Findings"). Avoid creating separate files for temporary outputs related to a single task, ensuring each task file is self-contained.

      #### Task Execution with Repository Context and Research Tools

      When executing tasks, leverage `vibe-tools` to gather comprehensive context about the code, documentation, and for research or troubleshooting:

      - **Gathering Codebase Context with `vibe-tools repo`**:
        Before diving into implementation, or when trying to understand existing code, use [`vibe-tools repo`](mdc:.cursor/rules/vibe-tools.mdc) to get insights.
        ```bash
        # Get context for a specific feature implementation
        vibe-tools repo "Find all files related to memory management in this repository and explain their relationships."

        # Understand existing patterns before implementation
        vibe-tools repo "Show examples of memory file updates in recent commits to understand the established patterns."

        # Get context on specific code areas
        vibe-tools repo "Explain how task status updates are currently implemented in the ai-agile-workflow rule."
        ```

      - **Research and Troubleshooting with `vibe-tools web`**:
        If you encounter issues or need to research solutions, use [`vibe-tools web`](mdc:.cursor/rules/vibe-tools.mdc).
        ```bash
        # Research best practices or solutions
        vibe-tools web "What are the best practices for handling asynchronous operations in TypeScript with Express?"

        # Troubleshoot error messages
        vibe-tools web "How to resolve 'TypeError: Cannot read property 'map' of undefined' in React?"
        ```

      - **Interactive Debugging and Web UI Testing with `vibe-tools browser`**:
        For tasks involving web UIs, use [`vibe-tools browser`](mdc:.cursor/rules/vibe-tools.mdc) to interact with pages, observe behavior, or extract information.
        ```bash
        # Observe interactive elements on a page
        vibe-tools browser observe "interactive elements" --url=https://example.com/my-feature-page

        # Test a user flow
        vibe-tools browser act "Click the 'Login' button | Type 'testuser' into '#username' | Type 'password123' into '#password' | Click '#submit'" --url=https://localhost:3000

        # Extract specific data from a page
        vibe-tools browser extract "all product titles and prices" --url=https://example.com/products
        ```

      When executing tasks that involve memory file updates, ensure AI assistants have proper formatting context by referencing the `memory-management.mdc` guidelines. For example:
      ```bash
      # Review memory file update approach before making changes
      vibe-tools repo "Review my approach for updating workflow-status.md with new task information. Does it follow the memory-management.mdc guidelines? Specifically check for:
      1. Properly updating existing sections rather than creating duplicates
      2. Maintaining the correct timestamp line at the end
      3. Following proper section merging for lists and tables
      4. Using the correct date format according to date-consistency-enforcer"
      ```

      When executing tasks:
      - Continuously update the relevant memory files to maintain context
      - Use `Sequential Thinking` for analyzing each task step
      - Keep the memory files and knowledge graph in sync
      - Follow the update guidelines in [memory-management](mdc:.cursor/rules/memory-management.mdc)

      ### Step 5: Update Task Status

      1. Open the task document
      2. Update the status field
      3. **When a task is completed:**
         - **You MUST move the task file to `docs/tasks/done/` (MANDATORY for both AI and users)** (e.g., `mv docs/tasks/[task-id].md docs/tasks/done/`)
         - Update the memory file
         - Update the plan document
         - **Refer to the "Automated Memory Updates on Task Completion" section in the [memory-management](mdc:.cursor/rules/memory-management.mdc) rule for details on updating memory files and knowledge graph entries with comprehensive implementation details** (MANDATORY)
      4. Ask the AI to update the feature status:

      #### Automated Memory File Updates for Task Completion

      When updating memory files upon task completion, use vibe-tools to ensure proper formatting:

      ```bash
      # Generate memory file update with proper formatting
      vibe-tools repo "Summarize the completed task [task-id] with focus on implementation details, technical decisions, and lessons learned" --save-to task-summary.txt

      # Format the update for memory files according to strict guidelines
      vibe-tools ask "$(cat << 'EOF'
      Format this task summary as updates for the following memory files, following memory-management.mdc guidelines exactly:

      1. workflow-status.md:
         - Update 'Task History' table with the new completed task
         - Add to 'Recent Updates' section
         - Ensure the 'Updated: [today's date]' is the very last line

      2. domain-knowledge.md:
         - Add relevant technical decisions to the 'Technical Decisions' section
         - Add any new implementation patterns to the 'Implementation Patterns' section
         - Ensure content is merged with existing sections, not duplicated
         - Maintain the exact formatting shown in memory-management.mdc

      IMPORTANT: Always maintain existing structure, merge with existing sections, and keep timestamp at the very end.
      EOF
      )"
      ```

      When a task's status changes:
      - You MUST update all relevant memory files using `Sequential Thinking` to ensure thorough analysis
      - Update at minimum the workflow-status.md, domain-knowledge.md, and any task-specific memory files
      - This context preservation is CRITICAL for continuity across sessions

      > **Warning:** If completed task files are not moved to `docs/tasks/done/`, workflow tracking and reporting will be inaccurate. This step is required for all completed tasks.

      The AI will:
      1. Check all related tasks
      2. Update the feature status in the features document
      3. Move completed features to the "Completed Features" section when all tasks are done

      #### Rule Creation Task Completion

      When completing a task related to creating or updating a cursor rule:

      1. Follow the standard task completion steps (update status, move to done directory, etc.)
      2. Additionally, you MUST update the rule index file:
         - Open `.cursor/rules/00-rule-index.mdc`
         - Follow the "Automatic Index Updates" guidelines:
           - For new rules: Add entry to appropriate category table
           - For updated rules: Update description/category if changed
           - For renamed rules: Update all references
           - For removed rules: Remove the entry
         - Update the `total_rules` count in the Metadata section
         - Update the `last_updated` date in the Metadata section using the current date obtained following [date-consistency-enforcer](mdc:.cursor/rules/date-consistency-enforcer.mdc) (prioritize `mcp_time_get_current_time` tool, fallback to `date +%Y-%m-%d`)
      3. Request the AI to verify the rule index update with:
         ```
         update rule index
         ```
         or similar trigger phrases as documented in the rule index file.

      ### Step 6: Track Progress

      Use the following prompt to generate progress reports:

      ```
      Generate progress report for [feature title or ID]
      ```

      The AI will:
      1. Analyze all related tasks
      2. Calculate completion percentage
      3. Identify blockers or dependencies
      4. Generate a summary report

      ### Memory File Update Best Practices

      When updating memory files, follow these critical best practices to maintain coherence and prevent duplication:

      1. **Search for Existing Sections**: Before adding a new section, always check if a section with the same name already exists in the file
         - Use search functionality (Ctrl+F/Cmd+F) to find existing sections
         - If a section exists, merge into it rather than creating a duplicate

      2. **Proper Section Merging**: When updating existing sections, follow these guidelines:
         - **Lists**: Integrate new items at the top or bottom of the existing list, maintaining formatting consistency
         - **Tables**: Add new rows to existing tables, don't create duplicate tables
         - **Text**: Enhance existing paragraphs or add new paragraphs within the section
         - **Code Blocks**: Update existing code blocks or add new ones with clear comments

      3. **Timestamp Management**:
         - The `## Updated: YYYY-MM-DD` line must ALWAYS be the last line in the file
         - There should only be ONE such line per file
         - Always update this timestamp when making changes
         - Use the current date obtained following [date-consistency-enforcer](mdc:.cursor/rules/date-consistency-enforcer.mdc) (prioritize `mcp_time_get_current_time` tool, fallback to `date +%Y-%m-%d`)

      4. **Handling the Current State Section**:
         - Always update the existing "Current State" section
         - Don't create a new one at the end of the file
         - Update all fields to reflect the current status

      5. **Task History Maintenance**:
         - Add new tasks to the existing Task History table
         - Sort by date (newest first) or status
         - Don't create duplicate Task History tables

      6. **Content Integration Examples**:

         **Example 1: Updating Lists**
         ```markdown
         # INCORRECT ❌
         ## Recent Updates
         - Update 1 (2025-05-01)
         - Update 2 (2025-05-02)

         ## Recent Updates
         - Update 3 (2025-05-03)
         ```

         ```markdown
         # CORRECT ✓
         ## Recent Updates
         - Update 3 (2025-05-03)
         - Update 1 (2025-05-01)
         - Update 2 (2025-05-02)
         ```

         **Example 2: Timestamp Placement**
         ```markdown
         # INCORRECT ❌
         ## Updated: 2025-05-01

         ## Recent Updates
         - New update (2025-05-02)

         ## Updated: 2025-05-02
         ```

         ```markdown
         # CORRECT ✓
         ## Recent Updates
         - New update (2025-05-02)

         ## Updated: 2025-05-02
         ```

      7. **Memory File Update Process**:
         - Open the memory file
         - Identify all sections that need updating
         - Search for each section name
         - Merge new content into existing sections
         - Add entirely new sections only if they don't exist
         - Ensure the Updated timestamp is the last line
         - Save the file

      ### Memory File Automation with Vibe-Tools

      The following section provides comprehensive guidance on using vibe-tools commands to automate memory file updates while maintaining strict adherence to memory-management.mdc formatting requirements.

      #### Providing Context to External AI Assistants

      When using external AI assistants via vibe-tools, it's crucial to provide sufficient context about memory file formatting requirements. Here are key approaches:

      1. **Explicit Formatting Instructions**:
         Always include explicit memory file formatting instructions in your prompts to external AI assistants:

         ```bash
         vibe-tools ask "Update the workflow-status.md memory file with the following information: [info]

         Ensure formatting follows these guidelines:
         1. Look for existing sections first and don't duplicate
         2. Merge content into existing sections
         3. Keep 'Updated: YYYY-MM-DD' as the very last line
         4. Use proper formatting for tables and lists
         5. Don't add extra blank lines around the timestamp"
         ```

      2. **Include Document Context**:
         Use the `--with-doc` option to provide direct access to memory-management.mdc and other relevant documentation:

         ```bash
         # Include memory-management.mdc as context
         vibe-tools ask "Update workflow-status.md with new task status" --with-doc="https://raw.githubusercontent.com/bfra-me/works/main/.cursor/rules/memory-management.mdc"

         # Include both memory-management.mdc and the current workflow-status.md
         vibe-tools ask "Add task X to workflow-status.md" --with-doc="https://raw.githubusercontent.com/bfra-me/works/main/.cursor/rules/memory-management.mdc" --with-doc="https://raw.githubusercontent.com/bfra-me/works/main/docs/memory/workflow-status.md"
         ```

      3. **Provide Examples**:
         Always include concrete examples of correctly formatted memory files in your prompts:

         ```bash
         vibe-tools ask "Format this as an update to workflow-status.md following this example exactly:

         ```markdown
         # Workflow Status Memory

         ## Current State
         - **Current Date**: 2025-05-06
         - **Active Project**: Project X

         ## Task History
         | Task ID | Task Name | Status | Completion Date |
         |---------|-----------|--------|----------------|
         | 2025-05-06-01 | Task A | Completed | 2025-05-06 |

         ## Recent Updates
         - Added Task A to Task History (2025-05-06)

         ## Updated: 2025-05-06
         ```"
         ```

      #### Automated Script Templates

      Use these script templates to automate common memory file update operations:

      1. **Workflow Status Update Script**:

         ```bash
         #!/bin/bash

         # Get current date with preferred method
         TODAY=$(date +%Y-%m-%d)

         # Gather task completion information
         echo "Enter the Task ID (e.g., 2025-05-06-01):"
         read TASK_ID

         echo "Enter the Task Name:"
         read TASK_NAME

         # Generate a summary of the completed task
         vibe-tools repo "Summarize the implementation of task $TASK_ID ($TASK_NAME). Include:
         1. What was accomplished
         2. Key technical decisions
         3. Any challenges and solutions" --save-to task-summary.txt

         # Format the update for workflow-status.md with explicit formatting requirements
         TASK_SUMMARY=$(<task-summary.txt)
         vibe-tools ask "Format this task summary as updates for workflow-status.md, following these EXACT requirements:
         1. Add the task to the 'Task History' table with:
            - Task ID: $TASK_ID
            - Task Name: $TASK_NAME
            - Status: Completed
            - Completion Date: $TODAY
         2. Add a new entry at the TOP of the 'Recent Updates' section:
            - Completed task $TASK_ID: $TASK_NAME ($TODAY)
         3. Update the 'Current Task' field in 'Current State' if this was the current task
         4. CRITICAL FORMATTING REQUIREMENTS:
            - Always search for existing sections before adding content
            - Merge into existing sections rather than creating duplicates
            - Keep the 'Updated: $TODAY' line as the very last line in the file
            - Maintain existing table structure and formatting
            - Never create duplicate sections or timestamps
         Content to format:
         $TASK_SUMMARY
         \nFormat your response as markdown suitable for direct addition to the memory file." --save-to workflow-update.md

         # Apply the update to workflow-status.md
         # (In practice, you would need to carefully merge this with the existing file)
         ```

      2. **Domain Knowledge Update Script**:

         ```bash
         #!/bin/bash

         # Get current date with preferred method
         TODAY=$(date +%Y-%m-%d)

         # Domain knowledge extraction
         echo "Extracting domain knowledge..."
         vibe-tools repo "Identify domain knowledge in the completed task $TASK_ID: $TASK_NAME.
         Extract:
         1. Core concepts implemented or used
         2. Implementation patterns applied
         3. Technical decisions made and their rationale
         4. Lessons learned" > domain-extract.txt

         # Format for domain-knowledge.md
         # UPDATED: Using the recommended variable approach instead of nested heredocs
         DOMAIN_EXTRACT=$(<domain-extract.txt)
         vibe-tools ask "Format this information as updates for domain-knowledge.md following these EXACT requirements:
         1. Ensure each item is categorized in the appropriate section:
            - 'Core Concepts' for key concepts
            - 'Implementation Patterns' for code patterns
            - 'Technical Decisions' for decisions and rationales
            - 'Lessons Learned' for insights gained
         2. Follow all memory file formatting requirements:
            - Search for existing sections before adding
            - Merge content into existing sections (don't create duplicates)
            - Keep the 'Updated: $TODAY' line at the very end
            - Format consistently with the existing file
            - Never duplicate section headings
         Content to format:
         $DOMAIN_EXTRACT" > domain-knowledge-updates.md

         # Apply to domain-knowledge.md (simplified example)
         echo "Review domain-knowledge-updates.md and apply to docs/memory/domain-knowledge.md"
         ```

      3. **Complete Memory Update Script**:

         ```bash
         #!/bin/bash

         # Get current date with preferred method
         TODAY=$(date +%Y-%m-%d)

         # Task information
         TASK_ID="$1"
         TASK_NAME="$2"

         if [ -z "$TASK_ID" ] || [ -z "$TASK_NAME" ]; then
           echo "Usage: $0 <task-id> <task-name>"
           exit 1
         fi

         # Move the task to done directory
         mv "docs/tasks/$TASK_ID.md" "docs/tasks/done/"

         # Generate comprehensive task summary
         vibe-tools repo "$(cat << 'EOF'
         Generate a comprehensive summary of task $TASK_ID: $TASK_NAME, including:
         1. Implementation details and approach
         2. Technical decisions made and rationales
         3. Components or files modified
         4. New concepts or patterns introduced
         5. Lessons learned and challenges overcome
         EOF
         )" --save-to task-summary.txt

         # Update all relevant memory files with proper formatting
         vibe-tools ask "$(cat << 'EOF'
         Generate updates for ALL relevant memory files based on this task summary.

         1. For workflow-status.md:
            - Update Task History table (add completed task)
            - Update Recent Updates section
            - Update Current State if necessary

         2. For domain-knowledge.md:
            - Add new concepts, patterns, and technical decisions

         3. For architecture.md (if applicable):
            - Update component relationships if changed

         CRITICAL FORMATTING REQUIREMENTS:
         - Format according to memory-management.mdc examples EXACTLY
         - Always search for existing sections before adding content
         - Merge into existing sections rather than creating duplicates
         - Keep 'Updated: $TODAY' as the VERY LAST line in EACH file
         - Never create duplicate sections or timestamps
         - Use consistent formatting for all sections

         Present updates for EACH memory file separately as markdown blocks ready for insertion.
         EOF
         )" --save-to memory-updates.md

         # Output instructions for applying the updates
         echo "Review memory-updates.md and apply changes to the respective memory files"
         ```

      #### Best Practices for Memory File Automation

      When automating memory file updates with vibe-tools:

      1. **Always Include Formatting Context**:
         - Include explicit memory file formatting requirements in every prompt to external AI assistants
         - Reference memory-management.mdc specifically in your prompts
         - Provide examples of correctly formatted memory files
         - Use the `--with-doc` option to include direct access to memory-management.mdc
         - When using `--with-doc`, consider including both memory-management.mdc AND the specific memory file being updated:
           ```bash
           # Include both memory-management.mdc and the specific file being updated
           vibe-tools ask "Update workflow-status.md with completed task info" --with-doc="https://raw.githubusercontent.com/bfra-me/works/main/.cursor/rules/memory-management.mdc" --with-doc="https://raw.githubusercontent.com/bfra-me/works/main/docs/memory/workflow-status.md"
           ```
         - If context limits are a concern, always include at minimum these critical rules:
           1. Keep the 'Updated: YYYY-MM-DD' line as the VERY LAST line in the file
           2. Always search for and merge into existing sections, never create duplicates
           3. Use the exact date format YYYY-MM-DD obtained from date-consistency-enforcer
           4. Never add extra blank lines around the final timestamp (should be the last line with no trailing newlines)

      2. **Verify Outputs Before Application**:
         - ALWAYS review the formatted outputs generated by external AI assistants before applying to memory files
         - Check that all sections are properly merged and not duplicated
         - Ensure the timestamp is properly formatted and at the very end with no extra blank lines
         - Verify table and list formatting matches the expected structure
         - Manually merge the generated content into the target file, carefully preserving existing structure:
           ```bash
           # Example verification step
           echo "IMPORTANT: Before applying, review the generated updates and manually merge into the target file:"
           echo "1. Open both the generated file and the target memory file"
           echo "2. For each section in the generated file, find the corresponding section in the target file"
           echo "3. Carefully merge new content, preserving existing items"
           echo "4. Check that the timestamp is properly updated as the very last line"
           echo "5. Save the target file only after confirming all updates are properly merged"
           ```
         - After applying changes, use a consistency check to verify proper formatting:
           ```bash
           # Consistency check after updates
           vibe-tools repo "$(cat << 'EOF'
           Check docs/memory/workflow-status.md for these formatting issues:
           1. Duplicate '## Updated:' lines
           2. Duplicate section headers
           3. Extra blank lines around the timestamp
           4. Timestamp appearing in the middle instead of at the end
           5. Inconsistent table or list formatting
           Verify that the memory file maintains the exact structure specified in memory-management.mdc.
           EOF
           )"
           ```

      3. **Use Sequential Thinking**:
         - Break down complex memory file updates into manageable steps
         - Think through each section that needs updating
         - Consider how to merge with existing content
         - Analyze the current file structure before applying changes
         - Maintain the exact order and structure of sections as specified in memory-management.mdc

      4. **Enforce Date Consistency**:
         - Always follow the [date-consistency-enforcer](mdc:.cursor/rules/date-consistency-enforcer.mdc) rule for obtaining dates
         - Prefer using the `mcp_time_get_current_time` tool when available
         - Fall back to `date +%Y-%m-%d` when the MCP tool is unavailable
         - Use consistent date formatting across all memory files: YYYY-MM-DD

      5. **Knowledge Graph Integration**:
         - Update both memory files and the knowledge graph for complete context preservation
         - Create or update entities for new components, concepts, or patterns
         - Add appropriate relationships between entities
         - Add detailed observations to relevant entities

      6. **Testing Memory File Updates**:
         - Create test updates in separate files before applying to actual memory files
         - Verify formatting and content integrity
         - Check for structural issues like duplicate sections or misplaced timestamps
         - Have another AI assistant review your memory file updates for correctness

      By following these automation guidelines, you ensure that all memory files maintain strict formatting consistency even when updated through external AI assistants via vibe-tools commands.

      ## Related Rules

      - [memory-management](mdc:.cursor/rules/memory-management.mdc): Defines workflow status storage, references automated memory updates upon task completion, and relies on its context loading.
      - [date-consistency-enforcer](mdc:.cursor/rules/date-consistency-enforcer.mdc): Uses its date formatting for task IDs, completion dates, and update timestamps.
      - [cursor-rules-creation](mdc:.cursor/rules/cursor-rules-creation.mdc): Mentions updating the rule index as part of task completion for rule-related tasks.
      - [00-rule-index](mdc:.cursor/rules/00-rule-index.mdc): References updating the index file itself.
      - [mcp-tools-usage](mdc:.cursor/rules/mcp-tools-usage.mdc): Mentions using the Sequential Thinking tool/approach.
      - [anthropic-chain-of-thought](mdc:.cursor/rules/anthropic-chain-of-thought.mdc): Provides structure for Sequential Thinking process.
      - [user-preferences-awareness](mdc:.cursor/rules/user-preferences-awareness.mdc): Ensures workflow aligns with user preferences for communication and process.
      - [vibe-tools](mdc:.cursor/rules/vibe-tools.mdc): Provides the `vibe-tools plan` and `vibe-tools repo` commands integrated into this workflow.

      ### Memory Management Rule

      The AI-Assisted Agile Workflow integrates with the [memory-management](mdc:.cursor/rules/memory-management.mdc) rule to provide comprehensive context retention across conversations.

      - The Memory Management rule defines additional memory file types and templates
      - It provides guidelines for maintaining memory files and leveraging the knowledge graph
      - Together, these rules create a complete system for maintaining project context and workflow status

      ### Memory Manager

      The process for updating memory files and the knowledge graph upon task completion are now detailed within the [memory-management](mdc:.cursor/rules/memory-management.mdc) rule. This process involves:

      - Updating memory files with detailed implementation information
      - Creating knowledge graph entities for new components and concepts
      - Adding relationships between relevant entities
      - Recording observations about implementation patterns
      - Documenting technical decisions and their rationales

      This integration ensures that all task completions are thoroughly documented and easily retrievable in future development work.

      ## Templates

      All templates are stored in the `docs/templates/` directory:
      - [`docs/templates/task-template.md`](mdc:docs/templates/task-template.md)
      - [`docs/templates/plan-template.md`](mdc:docs/templates/plan-template.md)
      - [`docs/templates/feature-template.md`](mdc:docs/templates/feature-template.md)

      ## File Linking Guidelines

      When creating links in your plan or task documents:

      1. **Within Cursor rules**: Always use the `mdc:` prefix for ALL file links:
         ```markdown
         [rule-name](mdc:.cursor/rules/rule-name.mdc)
         [features document](mdc:docs/features.md)
         ```

      2. **In regular documentation files**: Use standard markdown links:
         ```markdown
         [Plan Document](../plans/plan-name.md)
         [Feature Description](/docs/features.md#feature-1-title)
         ```

      3. **For task documents**: When linking to plans, use relative paths:
         ```markdown
         [Implement a Hierarchical Rule Structure](/plans/cursor-rules-hierarchy.md)
         ```

      ## AI Commands Reference

      The following commands can be used with the AI assistant:

      | Command | Description |
      |---|----|
      | `Create a plan document for [feature]` | Generates a new plan document |
      | `Generate task documents from this plan` | Creates task documents from the current plan |
      | `Update feature status based on completed tasks` | Updates the central document |
      | `Generate progress report for [feature]` | Creates a status report |
      | `Suggest next tasks to work on` | Recommends priority tasks |
      | `Show all blocked tasks` | Lists tasks with unmet dependencies |
      | `Mark task [task-id] as completed` | Moves task to the done directory and updates status |
      | `Extend this plan with new phases` | Adds new phases to an existing plan |
      | `Consolidate plans for [feature1] and [feature2]` | Merges multiple plans |
      | `Update workflow status memory` | Updates the workflow-status.md file |
      | `Fix memory file sections` | Merges duplicate sections and ensures proper structure |
      | `Update rule index` | Updates the rule index to include new or modified rules |

      ## Example Workflow

      1. We identified several features for improving the project
      2. Created a plan document for a specific feature
      3. Generated task documents for the first phase of implementation
      4. As tasks are completed, we'll update their status
      5. The AI will help us track progress and update the central document

      ## Getting Started

      To start using this workflow:

      1. Ensure you have the required directory structure:
         ```
         docs/
         ├── features.md
         ├── plans/
         └── tasks/
         ```

      2. Open `docs/features.md` to view current features

      3. For any feature without a plan, ask the AI to create one:
         ```
         Create a plan document for Feature 2: Add New Authentication Method
         ```

      4. After reviewing the plan, generate tasks:
         ```
         Generate task documents from this plan
         ```

      5. Begin working on the generated tasks

examples:
  - input: |
      I have a new plan document for implementing the hierarchical rule structure. Can you generate task documents from it?
    output: |
      I'll help you generate task documents from your plan for implementing the hierarchical rule structure ([plan-name.md](mdc:docs/plans/plan-name.md)).

      First, I need to check for existing tasks for today to determine the correct sequence numbers. (Executing `list_dir docs/tasks`)

      Assuming today is 2025-05-04 and no tasks exist yet, I will create the following task files:

      **Creating `docs/tasks/2025-05-04-01.md`:**
      ```markdown
      # Task: Create Relationship Diagram
      ## Task ID: 2025-05-04-01
      ## Related Plan
      [Implement Hierarchical Rule Structure](mdc:docs/plans/plan-name.md)
      ## Description
      Map out the relationships between all existing Cursor rules...
      ## Acceptance Criteria
      - Visual diagram (e.g., Mermaid) created...
      ## Status
      Not Started
      ```

      **Creating `docs/tasks/2025-05-04-02.md`:**
      ```markdown
      # Task: Define Standard Linking Format
      ## Task ID: 2025-05-04-02
      ## Related Plan
      [Implement Hierarchical Rule Structure](mdc:docs/plans/plan-name.md)
      ## Description
      Specify the exact format for linking between rules...
      ## Acceptance Criteria
      - Linking format documented...
      ## Status
      Not Started
      ```
      (And so on for other tasks identified in the plan...)

      I will also update the [workflow status memory](mdc:docs/memory/workflow-status.md) to reflect these new tasks.

  - input: |
      This task has been completed. Please update the status.
    output: |
      I'll update the status of this completed task.

      Based on the current task document:
      1. Changing the status from "In Progress" to "Completed"
      2. Adding completion date ($(date +%Y-%m-%d))
      3. Moving this task file to the `docs/tasks/done/` directory
      4. Updating the workflow status memory file
      5. Updating the plan document

      The workflow status memory file has been updated with:
      - Task moved to completed tasks section
      - Task history updated with completion date
      - Next task identified and marked as current

      The plan document has been updated with:
      - This task moved to completed tasks section
      - Next task marked as active
      - Progress percentage updated

      Would you like me to generate a progress report for the related feature?

  - input: |
      I need to consolidate the memory-management-system.md plan into the existing memory-management.md plan.
    output: |
      I'll help you consolidate the memory-management-system.md plan into the existing memory-management.md plan.

      Here's my approach:

      1. First, I'll read both plan documents to understand their content and structure
      2. I'll create a consolidated version that:
         - Maintains the structure of the more comprehensive plan
         - Incorporates unique elements from both plans
         - Ensures a coherent flow with logical organization
         - Aligns task dependencies and timeline
         - Documents the consolidation in the overview section

      3. I'll update the memory-management.md file with the consolidated content
      4. I'll then delete the memory-management-system.md file since it's no longer needed
      5. Finally, I'll update the workflow-status.md memory file to reflect this consolidation

      After consolidation, I'll ensure that:
      - All feature references point to the consolidated plan
      - Task dependencies are properly aligned
      - The timeline is coherent and realistic
      - Any unique content from either plan is preserved

      Would you like me to proceed with this consolidation?

  - input: |
      I've completed the task to create a new TypeScript patterns rule. Please update the status.
    output: |
      I'll update the status of this completed task.

      Based on the current task document:
      1. Changing the status from "In Progress" to "Completed"
      2. Adding completion date ($(date +%Y-%m-%d))
      3. Moving this task file to the `docs/tasks/done/` directory
      4. Updating the workflow status memory file
      5. Updating the plan document

      Since this task involved creating a new cursor rule, I'll also update the rule index:
      1. Opening `.cursor/rules/00-rule-index.mdc`
      2. Adding the new rule to the "Coding Standards" category:
         ```markdown
         | [typescript-patterns](mdc:.cursor/rules/typescript-patterns.mdc) | Effective TypeScript patterns and practices for the monorepo | High |
         ```
      3. Updating the `total_rules` count from 23 to 24
      4. Updating the `last_updated` date to today's date ($(date +%Y-%m-%d))

      The rule index has been successfully updated to include the new TypeScript patterns rule.
      Would you like me to generate a progress report for the related feature?

  - input: |
      Generate a progress report for the User Management System feature.
    output: |
      # Progress Report: User Management System

      ## Overall Progress

      **Completion: 65%** (13/20 tasks completed)

      ## Phase Status

      | Phase | Completion | Tasks Completed | Tasks Remaining |
      |-------|------------|----------------|-----------------|
      | Authentication | 100% | 4/4 | 0 |
      | User Roles | 75% | 3/4 | 1 |
      | Profile Management | 60% | 6/10 | 4 |
      | Integration | 0% | 0/2 | 2 |

      ## Current Active Tasks

      1. Task ID: 2025-04-25-03 - Implement role permission verification
         - Status: Not Started
         - Assigned to: Unassigned
         - Blocking: 2 dependent tasks

      2. Task ID: 2025-05-02-01 - Add profile editing capabilities
         - Status: In Progress
         - Assigned to: AI Assistant
         - Dependencies: None

      ## Next Tasks in Queue

      1. Create admin dashboard
         - Complexity: High
         - Dependencies: Role permission verification

      2. Implement avatar upload feature
         - Complexity: Medium
         - Dependencies: None

      ## Blockers and Issues

      - No critical blockers identified
      - Scheduled tasks are progressing as expected

      ## Recommendations

      1. Complete Task 2025-04-25-03 to unblock dependent tasks
      2. Finish the profile editing implementation
      3. Begin planning for the integration phase

      ## Recent Milestones

      - Completed authentication system (2025-04-23)
      - Implemented basic role management (2025-05-02)
      - Added user profile storage (2025-05-02)

      Would you like more detailed information about any specific task or phase?

  - input: |
      I've noticed some duplicate sections in the workflow-status.md memory file. Please fix this issue.
    output: |
      I'll fix the duplicate sections in the workflow-status.md memory file.

      Looking at the file, I've identified several duplicated sections:
      - Multiple "Current State" sections
      - Duplicate "Task History" sections
      - Duplicate "Recent Updates" sections
      - Multiple "Context" sections
      - Duplicate "Updated:" timestamps

      I'll follow these steps to fix the issue:

      1. First, I'll read the entire file to understand its structure
      2. I'll identify all duplicate sections
      3. For each duplicate section:
         - I'll merge the content from both instances
         - Keep the most recent/complete information
         - Remove the duplicate section
      4. I'll ensure the "## Updated: YYYY-MM-DD" appears only once at the very end
      5. I'll maintain the proper logical structure of the document

      Let me make these corrections now...

      I've successfully merged:
      - Combined the duplicate "Current State" sections with the most up-to-date information
      - Merged the "Task History" tables, removing duplicated tasks
      - Combined the "Recent Updates" lists, preserving chronological order
      - Consolidated the "Context" sections, keeping all important information
      - Removed duplicate "Command History" and "Notes" sections
      - Ensured "## Updated: 2025-05-02" appears only once at the end

      The memory file now has a consistent structure with no duplicated sections, making it easier to maintain and understand.

metadata:
  priority: high
  version: 2.1
  tags:
    - workflow
    - agile
    - task-management
    - vibe-tools
  changelog:
    - version: 2.1
      changes:
        - Integrated `vibe-tools plan` and `vibe-tools repo` examples and guidance into the "Generate Task Documents" section of the AI-Agile Workflow.
    - version: 2.0
      changes:
        - Added comprehensive integration with vibe-tools commands for planning, research, and task management
        - Added detailed guidance for providing memory file formatting context to external AI assistants
        - Added script templates for automating memory file updates with proper formatting
        - Added best practices for maintaining memory file consistency when using external AI assistants
        - Added examples of using --with-doc option to provide direct access to memory-management.mdc
        - Added verification and consistency check processes for memory file updates
        - Updated all workflow steps to incorporate vibe-tools integration
        - Added vibe-tools to tags
    - version: 1.9
      changes:
        - Added Essential Context Loading section requiring memory files at the start of every interaction
        - Added Sequential Thinking Requirement section mandating its use for all workflow steps
        - Enhanced Execute Tasks and Update Task Status sections to require memory file updates
        - Added emphasis on context preservation across sessions
    - version: 1.8
      changes:
        - Added integration with auto-memory-manager rule for comprehensive task completion documentation
        - Added auto-memory-manager to the Related Rules section
        - Updated Step 5 to include notification about auto-memory-manager activation
    - version: 1.7
      changes:
        - Added detailed "Memory File Update Best Practices" section with explicit guidelines
        - Added examples of correct and incorrect memory file updates
        - Added specific instructions for merging duplicate sections
        - Added guidance on handling the "Updated:" timestamp
        - Added new AI command for fixing memory file sections
    - version: 1.6
      changes:
        - Removed specific references to Cursor rules system
        - Made the workflow applicable to general project development
        - Updated examples to use generic project features
        - Modified progress report example to use a User Management System feature
    - version: 1.5
      changes:
        - Incorporated content from the AI-Assisted Agile Workflow Guide
        - Added clear step-by-step workflow process matching the guide's approach
        - Added complete Getting Started section
        - Reformatted AI Commands Reference as a table for better readability
        - Added a new example for generating progress reports
    - version: 1.4
      changes:
        - Added file linking guidelines section
        - Updated cursor-rule-cross-references section to show correct mdc: syntax for all file types
        - Added examples of links to different file types
    - version: 1.3
      changes:
        - Added process for extending or consolidating plans
        - Added detailed guidance for updating workflow-status.md
        - Added reference to cursor-rule-cross-references rule
        - Updated memory file template with more details
        - Added new AI commands for plan extension and consolidation
    - version: 1.2
      changes:
        - Initial version
