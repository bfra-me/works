---
description: FOLLOW when MANAGING tasks to STREAMLINE feature development and progress tracking
globs: docs/plans/*.md,docs/tasks/**/*.md,docs/features.md,docs/memory/**/*.md
alwaysApply: false
---
# AI-Assisted Agile Workflow

Guidelines for using AI assistance to streamline agile development through automated task generation, progress tracking, and memory-enhanced workflow management.

<rule>
name: ai_agile_workflow
description: Process for generating well-defined task documents from plans and tracking progress using AI assistance
filters:
  - type: file_path
    pattern: "docs/(plans|tasks)/.*\\.md$"
  - type: file_path
    pattern: "docs/features\\.md$"
  - type: file_path
    pattern: "docs/memory/.*\\.md$"
  - type: message
    pattern: "(?i)(task generation|plan breakdown|agile workflow|track feature|create task)"
  - type: content
    pattern: "\\[Plan\\]|\\[Task\\]|\\[Status: (Not Started|In Progress|Blocked|Completed)\\]"

actions:
  - type: suggest
    message: |
      # AI-Assisted Agile Workflow

      ## Overview

      The AI-Assisted Agile Workflow is a comprehensive system that leverages artificial intelligence to enhance traditional agile development practices. This workflow transforms how teams plan, execute, and track development work by providing:

      - **Intelligent Task Generation**: Automatically break down complex features into manageable, well-defined tasks
      - **Contextual Memory Management**: Maintain persistent context across development sessions through memory files
      - **Progress Automation**: Track and report on progress with minimal manual intervention
      - **Enhanced Documentation**: Generate and maintain comprehensive documentation throughout the development lifecycle

      The workflow integrates seamlessly with development tools and practices, using AI to reduce administrative overhead while improving planning accuracy and delivery predictability.

      ## AI Commands Reference

      The following commands enable seamless interaction with the AI-assisted workflow. Each command is designed to handle specific aspects of the development process:

      ### Feature Management Commands
      | Command | Description | When to Use |
      |---|---|---|
      | `Create a plan document for [feature]` | Generates a comprehensive plan with phases and tasks | Starting work on a new feature after initial research |
      | `Update feature status based on completed tasks` | Synchronizes the central features document with task progress | After completing significant milestones or tasks |
      | `Generate progress report for [feature]` | Creates detailed status reports with metrics and insights | During sprint reviews or stakeholder updates |

      ### Task Management Commands
      | Command | Description | When to Use |
      |---|---|---|
      | `Generate task documents from this plan` | Creates individual task files from plan phases | After finalizing a comprehensive plan document |
      | `Mark task [task-id] as completed` | Moves task to done directory and updates all references | When a task has met all acceptance criteria |
      | `Show all blocked tasks` | Lists tasks with unmet dependencies and blocking issues | During daily standups or planning sessions |
      | `Suggest next tasks to work on` | Recommends priority tasks based on dependencies and complexity | When deciding what to work on next |

      ### Workflow Management Commands
      | Command | Description | When to Use |
      |---|---|---|
      | `Update workflow status memory` | Refreshes the workflow-status.md file with current state | At the start of each development session |
      | `Extend this plan with new phases` | Adds additional phases to existing plans | When scope expands or new requirements emerge |
      | `Consolidate plans for [feature1] and [feature2]` | Merges related plans for coordinated implementation | When features have significant overlap or dependencies |

      ## Leveraging `vibe-tools`
      Throughout this workflow, when specific commands or interactions with AI models are described (e.g., for research, planning, task generation, codebase analysis), **`vibe-tools` should be the preferred method of execution if available.** This ensures consistent, context-aware, and powerful AI assistance. Refer to the [vibe-tools documentation](mdc:.cursor/rules/vibe-tools.mdc) for command details.

      ## Document Types

      *(Note: Placeholders like `[Title]` or `${variable}` in templates should be filled by the AI based on context.)*

      ### 1. Central Reference Document ([features.md](mdc:docs/features.md))

      This document tracks all features for improving the project, including:

      ```markdown
      # Project Features

      ## Current Features

      ### Feature 1: [Title]

      - **Description**: Brief description of the feature
      - **Status**: [Not Started | In Progress | Blocked | Completed]
      - **Plan Document**: [Link to plan document]
      - **Priority**: [High | Medium | Low]
      - **Created**: YYYY-MM-DD
      - **Updated**: YYYY-MM-DD
      - **Progress**: [Description of progress or phases/tasks completed]

      ### Feature 2: [Title]

      ...

      ## Completed Features

      ### Feature X: [Title]

      - **Description**: Brief description of the feature
      - **Status**: Completed
      - **Plan Document**: [Link to plan document]
      - **Priority**: [High | Medium | Low]
      - **Created**: YYYY-MM-DD
      - **Completed**: YYYY-MM-DD
      - **Outcome**: Brief description of the outcome

      ## Updated: YYYY-MM-DD
      ```

      ### 2. Plan Documents (`docs/plans/[plan-name].md`)

      Each plan document outlines a comprehensive approach to implementing a feature:

      ```markdown
      # Plan: [Plan Title]

      ## Overview

      Brief description of the plan and its goals.

      ## Related Feature

      [Link to the feature in the features document]

      ## Success Criteria

      - Criterion 1
      - Criterion 2
      - ...

      ## Implementation Phases

      ### Phase 1: [Phase Title] (Estimated time to complete in days or weeks)

      **Objective**: Clear statement of the phase objective

      **Tasks**:

      1. [Task 1 description]
         - **Complexity**: [Low | Medium | High]
         - **Dependencies**: None
         - **Acceptance Criteria**: Clear criteria for completion

      2. [Task 2 description]
         - **Complexity**: [Low | Medium | High]
         - **Dependencies**: Task 1.1
         - **Acceptance Criteria**: Clear criteria for completion

      ### Phase 2: [Phase Title] (Estimated time to complete in days or weeks)

      ...

      ## Timeline

      - Phase 1: X days
      - Phase 2: Y days
      - ...
      - **Total**: Z days

      ## Resources Required

      - Resource 1
      - Resource 2
      - ...

      ## Updated: YYYY-MM-DD
      ```

      ### 3. Task Documents (`docs/tasks/[task-id].md`)

      Individual task documents derived from plan documents:

      ```markdown
      # Task: [Task Title]

      ## Task ID: YYYY-MM-DD-XX

      ## Related Plan

      [Link to the plan document]

      ## Description

      Detailed description of the task.

      ## Problem Analysis

      - Clear description of the issue or feature
      - List of potential causes or requirements
      - Affected systems or components
      - Performance/scaling considerations

      ## Acceptance Criteria

      - Criterion 1
      - Criterion 2
      - ...

      ## Complexity

      [Low | Medium | High]

      ## Estimated Effort

      [X hours | X days]

      ## Solution Design

      1. Approach 1:
        - Description
        - Pros and cons
        - Technical considerations

      2. Approach 2:
        - Description
        - Pros and cons
        - Technical considerations

      ## Implementation

      - [ ] High-level step 1
        - [ ] Sub-task 1.1
        - [ ] Sub-task 1.2
        - Success criteria: What defines completion
        - Dependencies: Required components/systems

      - [ ] High-level step 2
        - [ ] Sub-task 2.1
        - [ ] Sub-task 2.2
        - Success criteria: What defines completion
        - Dependencies: Required components/systems

      ## Assignee

      [Name or "Unassigned"]

      ## Notes

      Any additional notes or context.

      ## [Findings]

      This optional section can be used to document detailed analysis results, audit findings, or other
      task-specific information that doesn't fit cleanly into other sections. For tasks requiring complex
      analysis, this section may include:

      - Detailed audit results
      - Code review findings
      - Relationship mappings
      - Performance metrics
      - Test results
      - Custom subsections to organize findings

      ## Dependencies

      - [List of dependencies, if any]

      - Blocking tasks
      - Required features
      - External dependencies

      ## Status

      ### YYYY-MM-DD HH:mm

      [Not Started | In Progress | Blocked | Completed]

      - What's working: Current state of implementation
      - What's not: Current issues or challenges
      - Blocking issues: Any blockers preventing progress
      - Next actions: Immediate next steps
      - Documentation updates needed:
        - [ ] Feature documentation
        - [ ] API documentation
        - [ ] Component documentation
        - [ ] Test documentation

      ## History

      ### YYYY-MM-DD HH:mm - Initial Planning

      - ‚úì Completed: What was accomplished
      - ü§î Decisions: Key decisions made and why
      - ‚ùå Issues: Problems encountered and solutions
      - üìö Documentation: Documentation changes needed
      - ‚è≠Ô∏è Next: What this enables or unblocks
      ```

      ### 4. Workflow Status ([workflow-status.md](mdc:docs/memory/workflow-status.md))

      Tracks the current state of the workflow while enriching context for AI assistants:

      ```markdown
      # Workflow Status Memory

      ## Current State

      - **Current Date**: YYYY-MM-DD
      - **Active Projects**:
        1. [Project 1 name]
        2. [Project 2 name]
      - **Current Plans**:
        1. [Plan 1 name]
        2. [Plan 2 name]
      - **Current Phase**:
        1. [Phase 1 name] ([Project 1 name])
        2. [Phase 2 name] ([Project 2 name])
      - **Active Tasks**:
        - [Task 1 name] (Task ID: YYYY-MM-DD-XX)
        - [Task 2 name] (Task ID: YYYY-MM-DD-XX)
      - **Next Tasks**:
        - [Next task 1 name] (not assigned yet)
        - [Next task 2 name] (Task ID: YYYY-MM-DD-XX)

      ## Task History

      | Task ID | Task Name | Status | Completion Date |
      |---------|-----------|--------|-----------------|
      | YYYY-MM-DD-XX | [Task name] | [Status] | [Completion date] |

      ## Context

      [Additional context about the active tasks and projects]

      ## Recent Updates

      - [Update 1] (YYYY-MM-DD)
      - [Update 2] (YYYY-MM-DD)

      ## Command History

      \`\`\`bash
      # Recent commands executed as part of the workflow
      [Command 1]
      [Command 2]
      \`\`\`

      ## Notes

      - [Note 1]
      - [Note 2]

      ## Updated: YYYY-MM-DD
      ```

      ## Workflow Process

      ### Essential Context

      Before beginning any task in the workflow, you MUST load the following essential memory files into context:

      1. **[workflow-status.md](mdc:docs/memory/workflow-status.md)**: Provides current state of the workflow, active tasks, and recent updates
      2. **[architecture.md](mdc:docs/memory/architecture.md)**: Gives overview of system architecture and components
      3. **[user-preferences.md](mdc:docs/memory/user-preferences.md)**: Details user preferences for code style, tools, and workflow
      4. **[domain-knowledge.md](mdc:docs/memory/domain-knowledge.md)**: Contains domain-specific knowledge and terminology

      Loading these memory files is MANDATORY at the start of every interaction to ensure you have the necessary context for accurate planning and task execution. This process aligns with the [Memory Management System](mdc:.cursor/rules/memory-management.mdc) requirements for comprehensive context retention.

      ### Sequential Thinking Requirement

      Throughout this workflow, when 'Sequential Thinking', a 'step-by-step approach', or 'structured reasoning' is mentioned, it refers to the use of the **`mcp_sequential-thinking_sequentialthinking`** tool. This tool should be invoked to break down complex problems, plan multi-step solutions, and ensure thorough analysis.
      All steps in this workflow MUST utilize the `mcp_sequential-thinking_sequentialthinking` tool to ensure:
      1. Thorough analysis of each step
      2. Comprehensive planning
      3. Careful consideration of implications
      4. Step-by-step reasoning
      5. Context retention across sessions

      For any complex request or workflow step, use `Sequential Thinking` to break down the process into manageable steps, analyze each thoroughly, and document your reasoning process.

      When you see instructions that say "Use Sequential Thinking," this means you should either:
      1. Use the `mcp_sequential-thinking_sequentialthinking` tool when available, OR
      2. Structure your response with explicitly numbered thought steps, showing your reasoning process

      ### Memory Updates on Task Completion

      This workflow integrates directly with the [Memory Management System](mdc:.cursor/rules/memory-management.mdc) to automatically capture and retain knowledge from completed tasks. Memory updates are **automatically triggered** when task completion is detected.

      #### Task Completion Detection

      Memory updates are triggered by any of the following indicators:

      **Explicit Completion Statements:**
      - Messages containing: `(?i)(task completed|finished implementing|done with|completed task|task is done|fixed issue|implemented|resolved|finished|done)`
      - Content containing `Status: Completed` in task files
      - Task files moved to the `docs/tasks/done/` directory

      **Direct Update Requests:**
      - Messages containing: `(?i)(update memory files|refresh memory files|update memory|synchronize memory files)`

      #### Automatic Memory Update Process

      When task completion is detected, the following updates are **automatically executed**:

      1. **Extract Task Information**:
         - Task type (Feature Implementation, Bug Fix, Configuration, etc.)
         - Core components affected by the task
         - Problem solved or objective achieved
         - Solution implemented and approach taken
         - Key learnings, challenges, and insights gained

      2. **Update Core Memory Files**:
         - **[workflow-status.md](mdc:docs/memory/workflow-status.md)**: Mark completed task as "Completed" in Task History table and update Current State section
         - **[domain-knowledge.md](mdc:docs/memory/domain-knowledge.md)**: Add new insights, implementation patterns, or technical decisions to relevant sections
         - **Task-Specific Documentation**: Create detailed implementation notes in dedicated files when appropriate

      #### Memory Update Structure for workflow-status.md

      When updating `workflow-status.md`, follow this structured format:

      ```markdown
      ## Task History

      | Task ID | Task Name | Status | Completion Date |
      |---------|-----------|--------|-----------------|
      | YYYY-MM-DD-XX | [Completed task name] | Completed | YYYY-MM-DD |
      | [Previous entries...] |

      ## Recent Updates

      - Completed [task name] - [brief description of outcome] (YYYY-MM-DD)
      - [Previous updates...]

      ## Updated: YYYY-MM-DD
      ```

      **Critical Guidelines:**
      - Always update existing sections rather than creating duplicates
      - Maintain chronological order (newest entries first)
      - Use consistent date format following [date-consistency-enforcer](mdc:.cursor/rules/date-consistency-enforcer.mdc)
      - Keep the "Updated" timestamp as the very last line in the file

      ### Step 1: Capture Features

      #### Feature Definition with Web Research
      Ideally, perform initial research *before* adding a feature to `docs/features.md` to better inform its definition and scope. Use `vibe-tools web` to conduct comprehensive research and competitor analysis. This ensures that features align with industry best practices and market needs:

      ```bash
      # Research best practices for a feature
      vibe-tools web "Research best practices for implementing semantic versioning in a monorepo structure similar to our project. Focus on automation and integration with existing workflows."

      # Analyze competitor implementations
      vibe-tools web "Compare approaches for implementing cross-references between Markdown files with focus on compatibility with VS Code and Cursor IDE."

      # Research specific technical approaches
      vibe-tools web "What are the current best practices for implementing cross-references in documentation that need to work in both web and IDE environments?"
      ```

      When you have specific URLs or documentation to reference, use the `--with-doc` option to provide more focused context:

      ```bash
      # Research with specific documentation as context
      vibe-tools web "Analyze best practices for rule-based documentation systems" --with-doc="https://example.com/documentation-standards.pdf"

      # Combine multiple documentation sources
      vibe-tools web "Compare our approach with industry standards" --with-doc="https://example.com/standard1.html" --with-doc="https://example.com/standard2.html"
      ```

      #### Repository Context with `vibe-tools repo`
      Before finalizing a new feature's definition in `docs/features.md`, gather context from the existing repository to understand potential overlaps, integration points, or relevant modules:

      ```bash
      # Gather repository context before defining a new feature
      vibe-tools repo "Before defining the '[new feature name]' feature, identify existing similar features, relevant modules (e.g., in 'src/components' or 'packages/utils'), and potential integration points within the current codebase."
      ```
      This helps in scoping the feature accurately and aligning it with the existing architecture.

      After completing your research, proceed with adding features to the central reference document:

      1. Open `docs/features.md`
      2. Add new features with the following structure:
         ```markdown
         ### Feature X: [Title]

         - **Description**: Brief description
         - **Status**: Not Started
         - **Plan Document**: Not created yet
         - **Priority**: [High | Medium | Low]
         - **Created**: YYYY-MM-DD
         - **Updated**: YYYY-MM-DD
         - **Progress**: Not Started
         ```

      #### Reviewing `docs/features.md` with `vibe-tools repo`
      After adding or updating features in `docs/features.md`, use `vibe-tools repo` to review the document for clarity, completeness, consistency, and alignment with project goals:

      ```bash
      # Review the features document
      vibe-tools repo "Review the updated 'docs/features.md' file. Check for:
      - Clarity and conciseness of feature descriptions.
      - Completeness of information (status, priority, etc.).
      - Consistency with existing features and terminology.
      - Alignment with overall project goals and roadmap.
      Provide suggestions for improvement."
      ```

      ### Step 2: Create Plan Documents

      1. For high-priority features, create a plan document in `docs/plans/`
      2. Use the following prompt with the AI:
         ```
         Create a plan document for implementing [feature title]
         ```
      3. The AI will generate a structured plan based on the feature
      4. Review and refine the plan as needed

      #### Planning with Vibe-Tools
      **Always use `vibe-tools plan` for generating plan documents if `vibe-tools` is available.**
      For more comprehensive planning with context-aware AI assistance, use `vibe-tools plan`. This approach ensures plans consider repository structure, related components, and implementation patterns:

      ```bash
      # Generate comprehensive implementation plan
      vibe-tools plan "Create a detailed implementation plan for adding cross-references capabilities to Cursor rules. Include phases, tasks, acceptance criteria and estimated story points."

      # Create plan with specific focus areas
      vibe-tools plan "Generate implementation plan for memory file automation with focus on maintaining strict formatting according to memory-management guidelines. Identify required updates to ai-agile-workflow.mdc."

      # Generate task breakdown within a plan
      vibe-tools plan "Break down the vibe-tools integration phase into discrete, estimable tasks with dependencies."
      ```

      When creating plans that involve memory file updates, always include memory formatting context in your prompts to ensure the AI has the necessary guidelines:

      ```bash
      # Plan with memory formatting context
      vibe-tools plan "Create implementation plan for feature X that includes memory file update steps. Include details on proper memory file formatting per memory-management.mdc, specifically:
      - Always search for existing sections before adding new ones
      - Merge content into existing sections rather than creating duplicates
      - Keep the 'Updated: YYYY-MM-DD' line as the very last line
      - Use proper section merging for lists, tables, and text
      - Follow the date-consistency-enforcer rule for obtaining dates"
      ```

      #### Reviewing Plans with Gemini (via `vibe-tools repo`)
      Once `vibe-tools plan` has generated an initial plan, it's crucial to review it with Gemini for a deeper, context-aware analysis:

      ```bash
      # Review a plan generated by vibe-tools plan
      vibe-tools repo "Review the following implementation plan for the feature '[feature name]'. The plan was generated by 'vibe-tools plan'.
      Plan Content:
      ---
      [Paste the full content of the generated plan here, or provide a path to a temporary file containing the plan]
      ---
      Focus on:
      - Feasibility and completeness of the outlined steps.
      - Identification of potential oversights or missing tasks.
      - Alignment with our current codebase structure, patterns, and best practices.
      - Adherence to project standards and requirements.
      - Sensible task breakdown and dependencies.
      Provide specific suggestions for improvement or areas needing clarification."
      ```

      #### Final Plan Content Review with `vibe-tools repo`
      Before the refined plan document is written to `docs/plans/[plan-name].md`, use `vibe-tools repo` to perform a final review of the *exact content* that will be saved. This ensures all feedback has been incorporated and the plan is ready.

      ```bash
      # Final review of plan document content
      vibe-tools repo "Perform a final review of this plan document content for the feature '[feature name]' before it is saved to the 'docs/plans/' directory.
      Final Plan Content:
      ---
      [Paste the complete final content of the plan document here]
      ---
      Check for:
      - Clarity and actionability of all sections.
      - Consistency in terminology and formatting.
      - Confirmation that all previous review feedback has been adequately addressed.
      - Overall readiness for developers to use as a guide."
      ```

      For high-priority features, create comprehensive implementation plans that break down the feature into phases and tasks. **Always use `vibe-tools plan`** to generate context-aware plans when available.

      ### Step 3: Generate Task Documents

      From each plan, generate specific task documents with clear acceptance criteria and dependencies. Check existing task IDs to determine the next available sequence number.

      **Before creating a new task document, you MUST check the `docs/tasks/` and `docs/tasks/done/` directories for existing task files for the current date (e.g., using `list_dir` tool). Use the next available sequence number (e.g., if `2025-05-02-01.md` exists, the next should be `2025-05-02-02.md`). Never overwrite an existing task file.**

      For more structured and context-aware task breakdown, leverage `vibe-tools`:

      #### Task Generation with Vibe-Tools
      **Always use `vibe-tools` for generating task documents if available.** Prefer `vibe-tools plan` to break down features or plans into tasks, or use `vibe-tools repo` for code-aware task definitions based on the current repository state.
      Using `vibe-tools` can provide more context-aware and structured task generation:

      - **Using `vibe-tools plan` for Task Breakdown:**
        `vibe-tools plan` can analyze a feature's objectives or a plan document to automatically suggest a breakdown into specific tasks.
        ```bash
        # Example: Break down a feature specified in a plan document
        vibe-tools plan "From the plan in docs/plans/my-feature-plan.md, generate actionable tasks for the frontend implementation phase."

        # Example: Save output directly to a task file (useful for initial task creation)
        vibe-tools plan "Break down the 'User Authentication' feature into tasks" --save-to=docs/tasks/$(date +%Y-%m-%d)-01.md
        ```
        *(Ensure the date command usage aligns with `date-consistency-enforcer.mdc` if used directly in rules, or prefer AI to generate full task IDs.)*

      - **Using `vibe-tools repo` for Code-Aware Task Definition:**
        `vibe-tools repo` offers contextual insights by leveraging the existing repository structure, helping to define tasks based on current code.
        ```bash
        # Example: Define tasks based on codebase structure for a refactoring effort
        vibe-tools repo "For the refactoring plan of the 'SettingsModule', identify tasks needed to update its dependencies in 'ProfileComponent' and 'AdminPanel'."

        # Example: Break down implementation based on current rule structures
        vibe-tools repo "Break down the implementation of cross-references into discrete tasks based on the current structure of Cursor rules. Consider file paths, parsing requirements, and rendering approaches."
        ```
      These commands ensure that task generation is informed by both the broader feature context and the specific details of the codebase.

      For more structured and context-aware task breakdown, use `vibe-tools plan`:
      ```bash
      # Generate task breakdown from plan
      vibe-tools plan "Break down this plan into specific tasks with complexity, dependencies, and acceptance criteria: [paste relevant part of plan here]"

      # Generate tasks with memory update requirements
      vibe-tools plan "Create task documents for implementing feature X. Include steps for proper memory file updates following memory-management.mdc guidelines. Each task should specify which memory files to update and how to maintain formatting integrity."

      # Save tasks directly to task files
      vibe-tools plan "Break down feature X implementation into tasks" --save-to=task-breakdown.md
      ```

      #### Reviewing Generated Tasks with Gemini (via `vibe-tools repo`)
      After tasks have been generated (e.g., by `vibe-tools plan` or manually based on a plan), review them using `vibe-tools repo` to ensure they are well-defined and actionable:

      ```bash
      # Review generated tasks
      vibe-tools repo "Review the following set of tasks generated for the plan/feature '[plan name / feature name]'.
      Tasks:
      ---
      [Paste the list of generated tasks, including titles, descriptions, acceptance criteria, etc., or provide a path to a temporary file containing them]
      ---
      Focus on:
      - Clarity and specificity of each task's description and title.
      - Actionability: Can a developer pick up this task and understand what to do?
      - Correctness and completeness of dependencies.
      - Measurable and clear acceptance criteria.
      - Reasonable estimation of complexity/effort (if included).
      Provide suggestions for improving task definitions."
      ```

      The AI will:
      1. Extract tasks from each phase
      2. Create individual task documents in `docs/tasks/`
      3. Name them with a pattern: `YYYY-MM-DD-XX.md` (e.g., `2025-05-06-01.md`). Obtain the date following [date-consistency-enforcer](mdc:.cursor/rules/date-consistency-enforcer.mdc), prefer `mcp_time_get_current_time` tool, fallback to `$(date +%Y-%m-%d)-XX.md`.
      4. Include all necessary details from the plan
      5. Update the memory file with new task information
      6. Update the plan document

      **Note:** Before creating a new task document, always check for existing task files to determine the next available sequence number. *(Consult [date-consistency-enforcer.mdc](mdc:.cursor/rules/date-consistency-enforcer.mdc) for rules on generating dates and ensuring sequence number uniqueness.)*

      ### Step 4: Execute Tasks

      1. Prioritize tasks based on dependencies and complexity
      2. Assign tasks to team members (if the assignee is known, otherwise assign to yourself)
      3. Update task status as work progresses:
         - Not Started
         - In Progress
         - Completed

      **Note on Task Documentation**: Keep task-specific notes, analyses, checklists, or findings directly within the corresponding task file (`docs/tasks/[task-id].md`) under appropriate headings (e.g., "## Task Analysis", "## Implementation Notes", "## Audit Findings"). Avoid creating separate files for temporary outputs related to a single task, ensuring each task file is self-contained.

      #### Task Execution with Repository Context and Research Tools
      When executing tasks, leverage `vibe-tools` to gather comprehensive context about the code, documentation, and for research or troubleshooting:

      - **Gathering Codebase Context with `vibe-tools repo`**:
        Before diving into implementation, or when trying to understand existing code, use [`vibe-tools repo`](mdc:.cursor/rules/vibe-tools.mdc) to get insights.
        ```bash
        # Get context for a specific feature implementation
        vibe-tools repo "Find all files related to memory management in this repository and explain their relationships."

        # Understand existing patterns before implementation
        vibe-tools repo "Show examples of memory file updates in recent commits to understand the established patterns."

        # Get context on specific code areas
        vibe-tools repo "Explain how task status updates are currently implemented in the ai-agile-workflow rule."
        ```

      - **Research and Troubleshooting with `vibe-tools web`**:
        If you encounter issues or need to research solutions, use [`vibe-tools web`](mdc:.cursor/rules/vibe-tools.mdc).
        ```bash
        # Research best practices or solutions
        vibe-tools web "What are the best practices for handling asynchronous operations in TypeScript with Express?"

        # Troubleshoot error messages
        vibe-tools web "How to resolve 'TypeError: Cannot read property 'map' of undefined' in React?"
        ```

      - **Interactive Debugging and Web UI Testing with `vibe-tools browser`**:
        For tasks involving web UIs, use [`vibe-tools browser`](mdc:.cursor/rules/vibe-tools.mdc) to interact with pages, observe behavior, or extract information.
        ```bash
        # Observe interactive elements on a page
        vibe-tools browser observe "interactive elements" --url=https://example.com/my-feature-page

        # Test a user flow
        vibe-tools browser act "Click the 'Login' button | Type 'testuser' into '#username' | Type 'password123' into '#password' | Click '#submit'" --url=https://localhost:3000

        # Extract specific data from a page
        vibe-tools browser extract "all product titles and prices" --url=https://example.com/products
        ```

      When executing tasks that involve memory file updates, ensure AI assistants have proper formatting context by referencing the `memory-management.mdc` guidelines. For example:
      ```bash
      # Review memory file update approach before making changes
      vibe-tools repo "Review my approach for updating workflow-status.md with new task information. Does it follow the memory-management.mdc guidelines? Specifically check for:
      1. Properly updating existing sections rather than creating duplicates
      2. Maintaining the correct timestamp line at the end
      3. Following proper section merging for lists and tables
      4. Using the correct date format according to date-consistency-enforcer"
      ```

      When executing tasks:
      - Continuously update the relevant memory files to maintain context
      - Use `Sequential Thinking` for analyzing each task step
      - Follow the update guidelines in [memory-management.mdc](mdc:.cursor/rules/memory-management.mdc)

      ### Step 5: Complete Tasks

      Upon task completion, begin the memory file update process defined in the [memory-management](mdc:.cursor/rules/memory-management.mdc) rule. This involves:

      1. **Signaling Completion**: Indicate task completion (e.g., "Task 2025-05-06-07 is complete", or updating status in the task file).
      2. **Invoking Memory File Update**: Use the `mcp_sequential-thinking_sequentialthinking` tool to work through the **Memory File Updates on Task Completion** section defined in `memory-management.mdc`.
      3. **Providing Summary**: Offer a concise summary of the completed task, focusing on key changes, outcomes, and any new insights gained.

      **Trigger Conditions:** Messages containing phrases like "task completed", "finished implementing", "done with", etc.
      **Required Updates:**
      - Mark the task as "Completed" in the task document
      - Update `workflow-status.md` task history
      - Move the completed task file to the `docs/tasks/done/` directory
      - Extract domain knowledge for `domain-knowledge.md`

      ### Step 6: Track Progress

      Maintain an overview of project progress by regularly updating the workflow status memory file and feature document with current states and completion information:
      1. Analyze all related tasks
      2. Calculate completion percentage
      3. Identify blockers or dependencies
      4. Generate a summary report

      ### Memory File Update Best Practices

      When updating memory files, follow these critical best practices to maintain coherence and prevent duplication:

      1. **Search for Existing Sections**: Before adding a new section, always check if a section with the same name already exists in the file
         - Use search functionality to find existing sections
         - If a section exists, merge into it rather than creating a duplicate

      2. **Proper Section Merging**: When updating existing sections, follow these guidelines:
         - **Lists**: Integrate new items at the top or bottom of the existing list, maintaining formatting consistency
         - **Tables**: Add new rows to existing tables, don't create duplicate tables
         - **Text**: Enhance existing paragraphs or add new paragraphs within the section
         - **Code Blocks**: Update existing code blocks or add new ones with clear comments

      3. **Timestamp Management**:
         - The `## Updated: YYYY-MM-DD` line must ALWAYS be the last line in the file
         - There should only be ONE such line per file
         - Always update this timestamp when making changes
         - Use the current date obtained following [date-consistency-enforcer](mdc:.cursor/rules/date-consistency-enforcer.mdc) (prioritize `mcp_time_get_current_time` tool, fallback to `date +%Y-%m-%d`)

      4. **Handling the Current State Section**:
         - Always update the existing "Current State" section
         - Don't create a new one at the end of the file
         - Update all fields to reflect the current status

      5. **Task History Maintenance**:
         - Add new tasks to the existing Task History table
         - Sort by date (newest first) or status
         - Don't create duplicate Task History tables

examples:
  - input: |
      I need to create a plan for implementing cross-references in our documentation system.
    output: |
      I'll help you create a plan for implementing cross-references in your documentation system. Let me use the AI-Assisted Agile Workflow to guide this process:

      First, I'll check if this feature is already captured in your features document. If not, we should add it there before creating a detailed plan.

      To research and create an effective plan, I'll use `vibe-tools`:

      ```bash
      vibe-tools plan "Create a detailed implementation plan for adding cross-references between markdown documents in our documentation system. The cross-references should work in both the web interface and IDEs like VS Code and Cursor."
      ```

      This will generate a comprehensive plan following the structure in the [Plan Template](mdc:docs/templates/plan-template.md), including:
      - Clearly defined phases
      - Specific tasks with complexity ratings
      - Dependencies between tasks
      - Acceptance criteria for each task

      Once generated, I'll review the plan and save it to `docs/plans/cross-references-implementation.md`. Then we can generate specific task documents from this plan.

      Would you like me to proceed with this approach?

  - input: |
      I have a new plan document for implementing the hierarchical rule structure. Can you generate task documents from it?
    output: |
      I'll help you generate task documents from your plan for implementing the hierarchical rule structure ([plan-name.md](/docs/plans/plan-name.md)).

      First, I need to check for existing tasks for today to use the next available sequence numbers. (Executing `list_dir docs/tasks`)

      Assuming today is 2025-05-04 and no tasks exist yet, I will create the following task files:

      **Creating `docs/tasks/2025-05-04-01.md`:**
      ```markdown
      # Task: Create Relationship Diagram
      ## Task ID: 2025-05-04-01
      ## Related Plan
      [Implement Hierarchical Rule Structure](mdc:docs/plans/plan-name.md)
      ## Description
      Map out the relationships between all existing Cursor rules...
      ## Acceptance Criteria
      - Visual diagram (e.g., Mermaid) created...
      ## Status
      Not Started
      ```

      **Creating `docs/tasks/2025-05-04-02.md`:**
      ```markdown
      # Task: Define Standard Linking Format
      ## Task ID: 2025-05-04-02
      ## Related Plan
      [Implement Hierarchical Rule Structure](mdc:docs/plans/plan-name.md)
      ## Description
      Specify the exact format for linking between rules...
      ## Acceptance Criteria
      - Linking format documented...
      ## Status
      Not Started
      ```
      (And so on for other tasks identified in the plan...)

      I'll also update the [workflow status memory](/docs/memory/workflow-status.md) to include these new tasks in the tracking system.

  - input: |
      I've completed the task for implementing the cross-reference syntax parser (Task ID: 2025-05-03-02)
    output: |
      I'll update the necessary documents and memory files to reflect this completed task.

      Based on the current task document:
      1. Moving this task file to the `docs/tasks/done/` directory
      2. Changing the status from "In Progress" to "Completed"
      3. Adding completion date ($(date +%Y-%m-%d))
      4. Updating the workflow status memory file
      5. Updating the plan document

      The workflow status memory file has been updated with:
      - Task moved to completed tasks section
      - Task history updated with completion date
      - Next task identified and marked as current

      The plan document has been updated with:
      - This task moved to completed tasks section
      - Next task marked as active
      - Progress percentage updated

      The memory files have been updated to reflect the completion of the cross-reference syntax parser task. Would you like me to generate a progress report for the related feature?

  - input: |
      Generate a progress report for the User Management System feature.
    output: |
      # Progress Report: User Management System

      ## Overall Progress

      **Completion: 65%** (13/20 tasks completed)

      ## Phase Status

      | Phase | Completion | Tasks Completed | Tasks Remaining |
      |-------|------------|----------------|-----------------|
      | Authentication | 100% | 4/4 | 0 |
      | User Roles | 75% | 3/4 | 1 |
      | Profile Management | 60% | 6/10 | 4 |
      | Integration | 0% | 0/2 | 2 |

      ## Current Active Tasks

      1. Task ID: 2025-04-25-03 - Implement role permission verification
         - Status: Not Started
         - Assigned to: Unassigned
         - Blocking: 2 dependent tasks

      2. Task ID: 2025-05-02-01 - Add profile editing capabilities
         - Status: In Progress
         - Assigned to: AI Assistant
         - Dependencies: None

      ## Next Tasks in Queue

      1. Create admin dashboard
         - Complexity: High
         - Dependencies: Role permission verification

      2. Implement avatar upload feature
         - Complexity: Medium
         - Dependencies: None

      ## Blockers and Issues

      - No critical blockers identified
      - Scheduled tasks are progressing as expected

      ## Recommendations

      1. Complete Task 2025-04-25-03 to unblock dependent tasks
      2. Finish the profile editing implementation
      3. Begin planning for the integration phase

      ## Recent Milestones

      - Completed authentication system (2025-04-23)
      - Implemented basic role management (2025-05-02)
      - Added user profile storage (2025-05-02)

      Would you like more detailed information about any specific task or phase?

metadata:
  priority: high
  version: 5.0.0
  tags:
    - workflow
    - task-management
    - memory
    - agile
    - vibe-tools
</rule>
