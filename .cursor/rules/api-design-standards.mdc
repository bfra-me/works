---
description: ADHERE when DESIGNING APIs to ENSURE consistency and type safety
globs: *.ts, *.tsx, *.d.ts, package.json
alwaysApply: false
---
# API Design Standards

<rule>
name: api_design_standards
description: Best practices for designing consistent, type-safe, and well-documented APIs in the bfra.me/works ecosystem
filters:
  - type: file_extension
    pattern: "\\.ts$|\\.tsx$|\\.d\\.ts$"
  - type: file_path
    pattern: "package\\.json$"
  - type: content
    pattern: "export|interface|type|function|class|public|expose"
  - type: message
    pattern: "(?i)(api design|public interface|breaking change|deprecation|versioning)"

actions:
  - type: suggest
    message: |
      # API Design Standards

      This guide outlines the standards for designing consistent, type-safe, and well-documented APIs across all packages in the bfra.me/works ecosystem.

      ## API Design Principles

      All public APIs in bfra.me/works should adhere to these core principles:

      1. **Consistency**: APIs should follow consistent patterns across packages
      2. **Type Safety**: All public APIs must be fully typed with TypeScript
      3. **Documentation**: Public interfaces must be documented with TSDoc comments
      4. **Backward Compatibility**: Breaking changes must follow proper versioning
      5. **Progressive Disclosure**: Simple tasks should be simple, complex tasks possible

      ## Public API Boundaries

      ### Export Structure

      Every package should clearly define its public API through explicit exports:

      ```typescript
      // ✅ Good: Clear and explicit exports
      // src/index.ts
      export { createConfig } from './create-config';
      export type { ConfigOptions } from './types';
      export * from './constants';

      // ❌ Bad: Exporting internal implementation details
      export * from './internal';
      export * from './utils';
      ```

      ### Package.json Export Field

      Use the exports field in package.json to strictly control what consumers can import:

      ```json
      "exports": {
        ".": {
          "import": "./lib/index.js",
          "types": "./lib/index.d.ts"
        },
        "./config": {
          "import": "./lib/config/index.js",
          "types": "./lib/config/index.d.ts"
        }
      }
      ```

      ## Type Safety Standards

      ### Interface vs Type Aliases

      For public APIs:

      ```typescript
      // ✅ Good: Interfaces for public API contracts
      export interface ConfigOptions {
        name: string;
        typescript?: boolean | TypescriptOptions;
        prettier?: boolean;
      }

      // ✅ Good: Type aliases for complex types, unions, and utility types
      export type ConfigValue = boolean | string | number | Record<string, unknown>;
      export type PackageName = `@bfra.me/${string}`;
      ```

      ### Use Discriminated Unions for Result Types

      ```typescript
      // ✅ Good: Clear discriminated unions for results
      export type Result<T, E = Error> =
        | { success: true; data: T }
        | { success: false; error: E };

      // Usage
      function processData(): Result<Data> {
        try {
          // ...
          return { success: true, data };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error : new Error(String(error))
          };
        }
      }
      ```

      ### Generics for Flexibility

      ```typescript
      // ✅ Good: Constrained generics for type safety with flexibility
      export function createEntity<T extends Record<string, unknown>>(data: T): Entity<T> {
        // Implementation
      }
      ```

      ## Naming Conventions

      ### Function Names

      - Use verb-noun pairs: `createConfig`, `validateInput`, `transformData`
      - Be specific and clear: `generateTypescriptConfig` vs `makeConfig`
      - Use consistent verbs across packages:

      | Action | Verb to Use | Example |
      |--------|------------|---------|
      | Create a new instance | `create` | `createConfig()` |
      | Validate data | `validate` | `validateOptions()` |
      | Transform data | `transform` | `transformTsConfig()` |
      | Format output | `format` | `formatCode()` |
      | Parse input | `parse` | `parseConfigFile()` |

      ### Type and Interface Names

      - Use PascalCase: `ConfigOptions`, `PackageManager`
      - Use descriptive, clear names: `CompilerOptions` vs `Options`
      - Add suffixes for special types:

      | Type Category | Suffix | Example |
      |---------------|--------|---------|
      | Configuration objects | `Options`, `Config` | `LintOptions` |
      | Function options | `Options` | `CreatePackageOptions` |
      | Function results | `Result` | `ValidationResult` |
      | Callbacks | `Callback`, `Handler` | `ErrorHandler` |
      | React components | `Props` | `ButtonProps` |

      ## Documentation Standards

      All public APIs must include TSDoc comments:

      ```typescript
      /**
       * Creates a new configuration with standardized settings.
       *
       * @param options - The configuration options
       * @param options.name - The name of the configuration
       * @param options.typescript - Whether to include TypeScript configuration
       * @param options.prettier - Whether to include Prettier configuration
       * @returns The created configuration object
       *
       * @example
       * ```ts
       * const config = createConfig({
       *   name: 'my-project',
       *   typescript: true,
       *   prettier: true
       * });
       * ```
       */
      export function createConfig(options: ConfigOptions): Config {
        // Implementation
      }
      ```

      ### Required Documentation Elements

      1. **Description**: Clear explanation of purpose
      2. **Parameters**: All parameters with types and descriptions
      3. **Return Value**: Type and description
      4. **Examples**: At least one usage example
      5. **Exceptions/Errors**: Document any errors that might be thrown

      ### Optional Documentation Elements

      1. **See Also**: References to related APIs
      2. **Deprecated**: Deprecation notice with migration path
      3. **Since**: Version when the API was introduced
      4. **Beta/Experimental**: Notice for non-stable APIs

      ## Deprecation Policy

      When deprecating APIs:

      1. Mark as deprecated with JSDoc/TSDoc:

      ```typescript
      /**
       * @deprecated Use createConfig() instead. Will be removed in v3.0.0.
       */
      export function makeConfig(options: ConfigOptions): Config {
        return createConfig(options);
      }
      ```

      2. Keep deprecated APIs working for at least one major version
      3. Provide clear migration path in documentation
      4. Export types for deprecated APIs for backward compatibility

      ## Versioning and Backward Compatibility

      APIs follow Semantic Versioning:

      - **MAJOR**: Breaking changes to the API (removing exports, changing parameter types)
      - **MINOR**: New features in backward-compatible way (new exports, optional parameters)
      - **PATCH**: Bug fixes that don't change the API

      ### Breaking Changes Checklist

      - Removing a public export
      - Changing parameter or return types
      - Changing function behavior in incompatible ways
      - Renaming exports without aliases
      - Modifying object structure

      ### Backward Compatible Changes

      - Adding new optional parameters
      - Adding new exports
      - Relaxing parameter types (more permissive)
      - Adding new properties to interfaces where they won't conflict

      ## API Design Patterns

      ### Builder Pattern for Complex Options

      ```typescript
      // ✅ Good: Builder pattern for complex configuration
      const config = new ConfigBuilder()
        .withTypescript({strict: true})
        .withPrettier({semi: false})
        .withEslint({})
        .build();
      ```

      ### Factory Functions

      ```typescript
      // ✅ Good: Factory function with defaults
      export function createPackage(name: string, options?: Partial<PackageOptions>): Package {
        return {
          name,
          version: options?.version ?? '0.0.0',
          private: options?.private ?? false,
          // ...more properties
        };
      }
      ```

      ### Fluent APIs for Chaining

      ```typescript
      // ✅ Good: Fluent API for configuration
      export class LintConfig {
        // ... properties and methods

        withRules(rules: Record<string, unknown>): this {
          this.rules = rules;
          return this;
        }

        withPlugins(plugins: string[]): this {
          this.plugins = plugins;
          return this;
        }
      }
      ```

      ## Anti-Patterns to Avoid

      ### ❌ Avoid: Inconsistent Result Types

      ```typescript
      // Bad: Inconsistent error handling
      function validateA(input: string): boolean {
        // Returns true/false
      }

      function validateB(input: string): string | null {
        // Returns error message or null
      }

      function validateC(input: string): void {
        // Throws error on validation failure
      }
      ```

      ### ❌ Avoid: Untyped Public APIs

      ```typescript
      // Bad: Using any in public API
      export function process(data: any): any {
        // Implementation
      }
      ```

      ### ❌ Avoid: Mutable Parameters

      ```typescript
      // Bad: Mutating input parameters
      export function processConfig(config: Config): void {
        // Modifies config in-place
        config.processed = true;
        config.options.strict = true;
      }
      ```

      ### ❌ Avoid: Excessive Use of Function Overloads

      ```typescript
      // Bad: Too many overloads that could be simplified
      export function createPackage(name: string): Package;
      export function createPackage(name: string, version: string): Package;
      export function createPackage(name: string, version: string, private: boolean): Package;
      export function createPackage(name: string, version: string, private: boolean, dependencies: Record<string, string>): Package;
      // ...and many more overloads
      ```

      Instead, use optional parameters or option objects.

      ### ❌ Avoid: Exposing Internal Types

      ```typescript
      // Bad: Exposing internal implementation details
      export interface PackageManager {
        // Public properties
        name: string;
        version: string;

        // Internal implementation details that shouldn't be exposed
        _registry: Map<string, unknown>;
        _processQueue: Queue<Task>;
      }
      ```

      ## Related Rules

      - [typescript-patterns](mdc:.cursor/rules/typescript-patterns.mdc) - General TypeScript best practices
      - [dependency-management](mdc:.cursor/rules/dependency-management.mdc) - Guidelines for managing package dependencies
      - [changeset-workflow](mdc:.cursor/rules/changeset-workflow.mdc) - Managing breaking changes with changesets

examples:
  - input: |
      I need to design a public API for a new package that handles configuration generation. What standards should I follow?
    output: |
      When designing your public API for a configuration generation package, follow these standards:

      1. **Define clear boundaries** for your public API:
         - Use explicit exports in your `index.ts` file
         - Configure package.json exports field to control what can be imported
         - Don't export internal implementation details

      2. **Use proper types**:
         - Use interfaces for your main public contracts:
           ```typescript
           export interface ConfigOptions {
             name: string;
             typescript?: boolean | TypescriptOptions;
             prettier?: boolean;
           }
           ```
         - Use discriminated unions for result types
         - Add generics for flexibility where appropriate

      3. **Follow naming conventions**:
         - Use consistent verb-noun pairs: `createConfig`, `validateConfig`
         - Use PascalCase for types/interfaces: `ConfigOptions`
         - Add appropriate suffixes: `Options`, `Config`, `Result`

      4. **Document everything**:
         - Add comprehensive TSDoc comments for all exports
         - Include examples in documentation
         - Document parameters, return values, and exceptions

      5. **Consider versioning implications**:
         - Use builder patterns for complex options (easier to extend)
         - Consider factory functions with optional parameters
         - Follow semantic versioning for any changes

      Remember to refer to the [typescript-patterns](mdc:.cursor/rules/typescript-patterns.mdc) rule for additional TypeScript best practices that apply to your API design.

  - input: |
      How should I handle deprecation of an existing API?
    output: |
      When deprecating an existing API, follow these steps:

      1. **Mark the API as deprecated using TSDoc**:
         ```typescript
         /**
          * @deprecated Use createConfig() instead. Will be removed in v3.0.0.
          */
         export function makeConfig(options: ConfigOptions): Config {
           return createConfig(options);
         }
         ```

      2. **Provide a migration path**:
         - Keep the deprecated API working for at least one major version
         - In documentation, clearly explain what to use instead
         - If possible, implement the deprecated API using the new API

      3. **Update the changelog**:
         - Document the deprecation in your changelog
         - Mention when it will be removed (typically next major version)
         - Link to migration guide if available

      4. **Consider adding runtime warnings**:
         - For critical APIs, add console warnings in development mode
         - Point users to documentation

      5. **Export types for backward compatibility**:
         - Keep exporting types used by the deprecated API

      6. **Create a changeset**:
         - Create a changeset using our [changeset-workflow](mdc:.cursor/rules/changeset-workflow.mdc)
         - Mark it as a minor change (not breaking yet)
         - When actually removing the API, mark it as a major change

      This approach gives users time to migrate while maintaining backward compatibility until the next major version.

metadata:
  priority: high
  version: 1.0
  tags:
    - api-design
    - typescript
    - documentation
    - versioning
  changelog:
    - version: 1.0
      changes:
        - Initial version
</rule>
