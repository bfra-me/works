---
description: Guidelines for creating and maintaining persistent memory files for AI assistants
globs:
alwaysApply: true
---
# Memory Management

Guidelines for managing AI memory files that maintain context and enhance assistant capabilities.

<rule>
name: memory_management
description: Guidelines for creating and maintaining persistent memory files for AI assistants
filters:
  - type: file_path
    pattern: "docs/memory/.*\\.md$"
  - type: message
    pattern: "(?i)(memory file|context retention|workflow status|project memory|knowledge graph)"
  - type: content
    pattern: "(?i)(current state|task history|context|recent updates|command history|memory)"

actions:
  - type: suggest
    message: |
      # Memory Management System

      The memory management system provides persistent context for AI assistants across conversations through structured memory files in the `docs/memory/` directory.

      ## Memory File Types

      ### 1. Workflow Status (`docs/memory/workflow-status.md`)

      Tracks the current state of the agile workflow:

      ```markdown
      # Workflow Status Memory

      ## Current State
      - **Current Date**: YYYY-MM-DD
      - **Active Project**: [Project name]
      - **Current Plan**: [Plan name]
      - **Current Phase**: [Phase name]
      - **Current Task**: [Task name] (Task ID: YYYY-MM-DD-XX)
      - **Next Task**: [Next task name] (Task ID: YYYY-MM-DD-XX)

      ## Task History
      | Task ID | Task Name | Status | Completion Date |
      |---------|-----------|--------|----------------|
      | YYYY-MM-DD-XX | [Task name] | [Status] | [Completion date] |

      ## Context
      [Additional context about the current task]

      ## Recent Updates
      - [Update 1] (YYYY-MM-DD)
      - [Update 2] (YYYY-MM-DD)

      ## Command History
      ```
      # Recent commands executed as part of the workflow
      [Command 1]
      [Command 2]
      ```

      ## Notes
      - [Note 1]
      - [Note 2]

      ## Updated: YYYY-MM-DD
      ```

      ### 2. Project Architecture (`docs/memory/architecture.md`)

      Maintains a living document of the project's architecture:

      ```markdown
      # Project Architecture Memory

      ## Current Architecture
      [Mermaid diagram or textual description of the architecture]

      ## Key Components
      - **Component A**: [Description and responsibilities]
      - **Component B**: [Description and responsibilities]

      ## Integration Points
      - **API**: [Endpoint descriptions]
      - **Event Bus**: [Event descriptions]

      ## Technical Decisions
      | Decision | Rationale | Date | Alternatives Considered |
      |----------|-----------|------|-----------------------|
      | [Decision] | [Rationale] | YYYY-MM-DD | [Alternatives] |

      ## Constraints
      - [Constraint 1]
      - [Constraint 2]

      ## Updated: YYYY-MM-DD
      ```

      ### 3. User Preferences (`docs/memory/user-preferences.md`)

      Records user preferences for code style, workflows, tools:

      ```markdown
      # User Preferences Memory

      ## Coding Style
      - **Formatting**: [Preferences for code formatting]
      - **Naming Conventions**: [Preferred naming conventions]
      - **Architecture Patterns**: [Preferred architectural patterns]

      ## Tool Preferences
      - **IDE**: [Preferred IDE and settings]
      - **CLI Tools**: [Preferred command-line tools]
      - **Frameworks**: [Preferred frameworks]

      ## Workflow Preferences
      - **Communication Style**: [Preferred communication style]
      - **Explanation Level**: [Preferred level of detail in explanations]
      - **AI Autonomy**: [Preferred level of AI autonomy]

      ## Updated: YYYY-MM-DD
      ```

      ### 4. Domain Knowledge (`docs/memory/domain-knowledge.md`)

      Captures domain-specific knowledge for the project:

      ```markdown
      # Domain Knowledge Memory

      ## Core Concepts
      - **Concept A**: [Definition and usage]
      - **Concept B**: [Definition and usage]

      ## Business Rules
      - [Rule 1]
      - [Rule 2]

      ## Terminology
      | Term | Definition | Context |
      |------|------------|---------|
      | [Term] | [Definition] | [Context] |

      ## External Resources
      - [Resource 1]: [Description and link]
      - [Resource 2]: [Description and link]

      ## Updated: YYYY-MM-DD
      ```

      ## Related Rules

      ### AI-Assisted Agile Workflow Rule

      The Memory Management system works in conjunction with the [AI-Assisted Agile Workflow](./.cursor/rules/ai-agile-workflow.mdc) rule to provide a comprehensive system for maintaining context and tracking project status.

      - The Agile Workflow rule defines the document structure and workflow processes
      - The Memory Management rule enhances context retention across conversations
      - Together they provide a complete system for managing project information and AI context

      ## Knowledge Graph Integration

      Memory files work in concert with the knowledge graph (MCP memory server) when available:

      1. **Entity Creation**: New entities should be created in the knowledge graph for:
         - Project components
         - User preferences
         - Technical decisions
         - Domain concepts

      2. **Relationship Mapping**: Create relationships between entities to build a connected knowledge network:
         ```
         [Component A] -> depends_on -> [Component B]
         [User] -> prefers -> [Coding Style]
         [Domain Concept] -> relates_to -> [Business Rule]
         ```

      3. **Memory Retrieval Process**:
         ```
         1. Check docs/memory/* files for context
         2. Use knowledge graph search for broader context
         3. Combine information for comprehensive understanding
         4. Update both memory files and knowledge graph with new information
         ```

      4. **Entity Types for Project Context**:
         - `component`: Technical components of the system
         - `preference`: User preferences and settings
         - `concept`: Domain concepts and terminology
         - `decision`: Technical decisions and rationales
         - `workflow`: Development workflows

      ## Memory File Management

      ### Creating or Updating Memory Files

      1. **Structure**: Follow the established templates
         - Use consistent headers and formatting
         - Maintain the same section order across updates
         - Include all required sections for the file type

      2. **Updates**: Follow these critical update protocols
         - **Always search for existing sections before adding new ones**
         - **Merge content into existing sections rather than creating duplicates**
         - **Keep the "## Updated: YYYY-MM-DD" line as the very last line in the file**
         - Use the current date from `$(date +%Y-%m-%d)` for the timestamp
         - There should only be ONE "## Updated: YYYY-MM-DD" line per file

      3. **Section Merging Guidelines**:
         - **For lists**: Add new items to the existing list in appropriate order
         - **For tables**: Add new rows to existing tables, don't create duplicate tables
         - **For narrative text**: Update existing paragraphs or add new ones
         - **For code blocks**: Update existing blocks or add new ones with clear comments

      4. **Avoiding Common Errors**:
         - **NEVER add a duplicate section with the same name** - search for existing sections first
         - **NEVER have multiple timestamp lines** - there should be only one "## Updated:" line
         - **NEVER leave the timestamp in the middle of the file** - it must be the very last line
         - **NEVER overwrite existing content** - merge or append appropriately

      5. **References**: Include links to other related memory files
         - Use relative paths (e.g., `/docs/memory/workflow-status.md`)
         - Maintain cross-references between related memory files

      6. **Synchronization**: Keep memory files in sync with the knowledge graph
         - Update both when new information is available
         - Ensure consistency between file content and graph entities

      ### Memory File Update Process

      When updating a memory file, follow this process:

      1. **Read the entire file** first to understand its structure and content
      2. **Identify sections to update** based on new information
      3. **Search for each section name** (using Ctrl+F/Cmd+F) before adding content
      4. **Merge new content into existing sections** rather than creating duplicates
      5. **Add entirely new sections only if they don't already exist**
      6. **Update the timestamp** at the end of the file using today's date
      7. **Review the file** to ensure no duplicate sections were created
      8. **Save the file** only after confirming proper structure

      ### Memory File Structure Maintenance

      To maintain the integrity of memory files:

      ```markdown
      # Correct ✓
      ## Section A
      Content for section A

      ## Section B
      Content for section B

      ## Updated: 2025-05-02
      ```

      ```markdown
      # Incorrect ❌
      ## Section A
      Content for section A

      ## Section B
      Content for section B

      ## Updated: 2025-05-01

      ## Section A
      New content for section A

      ## Updated: 2025-05-02
      ```

      ### Using Memory Files

      When starting a new conversation:
      1. Check `workflow-status.md` for current context
      2. Review relevant domain knowledge from `domain-knowledge.md`
      3. Consider user preferences from `user-preferences.md`
      4. Consult architecture details from `architecture.md`

      ### Knowledge Graph Commands

      When the knowledge graph MCP server is available:

      - `read_graph`: Get a complete view of the knowledge graph
      - `search_nodes`: Find specific information in the graph
      - `open_nodes`: Access specific entity details
      - `create_entities`: Add new information to the graph
      - `create_relations`: Connect entities meaningfully
      - `add_observations`: Update existing entities

      ## Suggested Memory Files

      In addition to the existing workflow status memory, consider creating these memory files for the project:

      1. **Architecture Memory** (`docs/memory/architecture.md`): Document the structure of the Cursor rules system
      2. **User Preferences** (`docs/memory/user-preferences.md`): Track preferred workflows and styles
      3. **Domain Knowledge** (`docs/memory/domain-knowledge.md`): Maintain knowledge about Cursor rules concepts
      4. **Decision Log** (`docs/memory/decisions.md`): Record key technical decisions

examples:
  - input: |
      Can you tell me about the current state of the project?
    output: |
      I'll check the memory files to understand the current project state.

      Based on the workflow status memory file, here's what I can tell you:

      **Current Project**: Cursor Rules System Improvement
      **Current Phase**: Implementation Phase 1
      **Active Task**: Create a relationship diagram for all rules (Task ID: 2025-04-25-01)
      **Next Task**: Define standard linking format (Task ID: 2025-04-25-02)

      The project is implementing a hierarchical rule structure with cross-references. The goal is to transform rules from independent documents into a navigable, interconnected knowledge system.

      Recent updates include:
      - Moving documentation from reference/ to docs/
      - Renaming "recommendations" to "features" to better align with agile methodology
      - Creating various templates for tasks, plans, and features
      - Setting up the memory management system

      Would you like more specific information about the current task, the overall plan, or another aspect of the project?

  - input: |
      I'd like to update the user preferences for this project.
    output: |
      I'll help you update the user preferences for this project. Let me first check if we have an existing user preferences memory file.

      I don't see an existing user preferences file in the docs/memory directory, so we should create one following our memory management guidelines.

      Here's a draft of a new user preferences memory file:

      ```markdown
      # User Preferences Memory

      ## Coding Style
      - **Formatting**: Uses Prettier with bfra.me/prettier-config for consistent formatting
      - **Naming Conventions**:
        - TypeScript: camelCase for variables and functions, PascalCase for classes and interfaces
        - Files: kebab-case for file names, descriptive and concise
      - **Architecture Patterns**: Modular design with clear separation of concerns

      ## Tool Preferences
      - **IDE**: VS Code with Cursor extension
      - **CLI Tools**: pnpm for package management
      - **Frameworks**: TypeScript for type safety

      ## Workflow Preferences
      - **Communication Style**: Clear, concise explanations with practical examples
      - **Explanation Level**: Medium detail, focusing on practical implementation
      - **AI Autonomy**: Medium - propose solutions but seek approval for implementation

      ## Documentation Preferences
      - **Format**: Markdown with structured headings
      - **Code Examples**: Include relevant, concise examples
      - **Comments**: JSDoc style for functions and interfaces

      ## Updated: 2025-04-25
      ```

      I can also update the knowledge graph with these preferences if you'd like. Would you like me to save this file to `docs/memory/user-preferences.md` or would you like to make any changes first?

  - input: |
      I've noticed some duplicate sections in the domain-knowledge.md memory file. Can you fix it?
    output: |
      I'll examine the domain-knowledge.md file and fix any duplicate sections I find.

      After reviewing the file, I've identified these issues:
      - Duplicate "Implementation Patterns" sections
      - Multiple "Updated:" timestamps throughout the file
      - Content that should be merged into existing sections

      I'll follow these steps to fix the issues:

      1. First, I'll read the entire domain-knowledge.md file to understand its structure
      2. I'll identify all duplicate section headers
      3. For each duplicate section:
         - I'll merge the content from both instances
         - Ensure no information is lost
         - Remove the duplicate section
      4. I'll check for multiple "## Updated:" lines and ensure only one exists at the end
      5. I'll maintain the proper hierarchical structure

      Here are the changes I'm making:
      - Merging both "Implementation Patterns" sections, keeping all unique patterns
      - Moving content from mid-file timestamp sections into their appropriate locations
      - Consolidating all "Technical Decisions" into a single section
      - Ensuring the "## Updated: 2025-05-02" appears only once at the very end

      The file has been fixed and now follows the proper memory file format with:
      - Each section appearing only once
      - All content properly merged
      - The "## Updated:" timestamp as the last line in the file
      - Consistent formatting throughout

      The domain knowledge memory file is now properly structured for easier maintenance and updates.

metadata:
  priority: high
  version: 1.1
  tags:
    - memory
    - context
    - workflow
    - knowledge-graph
  changelog:
    - version: 1.1
      changes:
        - Added detailed guidance on memory file update process
        - Added explicit section on avoiding duplicate sections
        - Added examples of correct and incorrect memory file structures
        - Enhanced guidance on timestamp placement
        - Added complete example of proper memory file update process
    - version: 1.0
      changes:
        - Initial version
</rule>
