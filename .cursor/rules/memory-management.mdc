---
description: ALWAYS USE when WORKING with memory files to PRESERVE context across sessions
globs: docs/plans/*.md,docs/tasks/**/*.md,docs/features.md,docs/memory/**/*.md
alwaysApply: true
---
# Memory Management

Guidelines for managing AI memory files that maintain context and enhance assistant capabilities.

<rule>
name: memory_management
description: Guidelines for creating and maintaining persistent memory files for AI assistants
filters:
  - type: file_path
    pattern: "docs/memory/.*\\.md$"
  - type: message
    pattern: "(?i)(memory file|context retention|workflow status|project memory|knowledge graph|remember across sessions)"
  - type: content
    pattern: "(?i)(\\b(current state|task history|context|recent updates|command history)\\b|\\bmemory\\b file)"

actions:
  - type: suggest
    message: |
      # Memory Management System

      The memory management system provides persistent context for AI assistants across conversations through structured memory files in the `docs/memory/` directory.

      ## Memory File Types

      *(Note: `${variable_name}` and `[Title]` placeholders in templates should be filled in based on context.)*

      ### 1. Workflow Status ([workflow-status.md](mdc:docs/memory/workflow-status.md))

      Tracks the current state of the agile workflow:

      ```markdown
      # Workflow Status Memory

      ## Current State

      - **Current Date**: YYYY-MM-DD
      - **Active Projects**:
        1. [Project 1 name]
        2. [Project 2 name]
      - **Current Plans**:
        1. [Plan 1 name]
        2. [Plan 2 name]
      - **Current Phase**:
        1. [Phase 1 name] ([Project 1 name])
        2. [Phase 2 name] ([Project 2 name])
      - **Active Tasks**:
        - [Task 1 name] (Task ID: YYYY-MM-DD-XX)
        - [Task 2 name] (Task ID: YYYY-MM-DD-XX)
      - **Next Tasks**:
        - [Next task 1 name] (not assigned yet)
        - [Next task 2 name] (Task ID: YYYY-MM-DD-XX)

      ## Task History

      | Task ID | Task Name | Status | Completion Date |
      |---------|-----------|--------|-----------------|
      | YYYY-MM-DD-XX | [Task name] | [Status] | [Completion date] |

      ## Context

      [Additional context about the active tasks and projects]

      ## Recent Updates

      - [Update 1] (YYYY-MM-DD)
      - [Update 2] (YYYY-MM-DD)

      ## Command History

      \`\`\`bash
      # Recent commands executed as part of the workflow
      [Command 1]
      [Command 2]
      \`\`\`

      ## Notes

      - [Note 1]
      - [Note 2]

      ## Updated: YYYY-MM-DD
      ```

      ### 2. Project Architecture ([architecture.md](mdc:docs/memory/architecture.md))

      Maintains a living document of the project's architecture:

      ```markdown
      # Project Architecture Memory

      ## Current Architecture

      [Mermaid diagram or textual description of the architecture]

      ## Key Components

      - **Component A**: [Description and responsibilities]
      - **Component B**: [Description and responsibilities]

      ## Integration Points

      - **API**: [Endpoint descriptions]
      - **Event Bus**: [Event descriptions]

      ## Technical Decisions

      | Decision | Rationale | Date | Alternatives Considered |
      |----------|-----------|------|-------------------------|
      | [Decision] | [Rationale] | YYYY-MM-DD | [Alternatives] |

      ## Implementation Guidelines

      - [Guideline 1]
      - [Guideline 2]

      ## Constraints

      - [Constraint 1]
      - [Constraint 2]

      ## Updated: YYYY-MM-DD
      ```

      ### 3. User Preferences ([user-preferences.md](mdc:docs/memory/user-preferences.md))

      Records user preferences for code style, workflows, tools, and other project-specific settings:

      ```markdown
      # User Preferences Memory

      ## Coding Style

      - **Formatting**: [Preferences for code formatting]
      - **Naming Conventions**: [Preferred naming conventions]
      - **Architecture Patterns**: [Preferred architectural patterns]

      ## Tool Preferences

      - **IDE**: [Preferred IDE and settings]
      - **CLI Tools**: [Preferred command-line tools]
      - **Frameworks**: [Preferred frameworks]

      ## Workflow Preferences

      - **Communication Style**: [Preferred communication style]
      - **Explanation Level**: [Preferred level of detail in explanations]
      - **AI Autonomy**: [Preferred level of AI autonomy]
      - **Development Process**: [Preferred development process]
      - **AI Assistant Operating Principles**: [Preferred operating principles for the AI assistant]

      [Manage other preferences that are relevant to the project (e.g. documentation style, code review preferences, etc.)]

      ## Updated: YYYY-MM-DD
      ```

      ### 4. Domain Knowledge ([domain-knowledge.md](mdc:docs/memory/domain-knowledge.md))

      Captures domain-specific knowledge for the project:

      ```markdown
      # Domain Knowledge Memory

      ## Core Concepts

      - **Concept A**: [Definition and usage]
      - **Concept B**: [Definition and usage]

      ## Business Rules

      - [Rule 1]
      - [Rule 2]

      ## Key Relationships

      - **Relationship 1**: [Description of the relationship]
      - **Relationship 2**: [Description of the relationship]

      ## Implementation Patterns

      - **Pattern A**: [Description of the pattern]
        - **Applied in**: [Title / ID of the task or plan that applied the pattern and link]
        - **Context**: [Description of the context in which the pattern is applied]
        - **Benefits**: [Benefits of using the pattern]
        - **Limitations**: [Limitations of using the pattern]

      - **Pattern B**: [Description of the pattern]
        - **Applied in**: [Title / ID of the task or plan that applied the pattern and link]
        - **Context**: [Description of the context in which the pattern is applied]
        - **Benefits**: [Benefits of using the pattern]
        - **Limitations**: [Limitations of using the pattern]

      ## Terminology

      | Term | Definition | Context |
      |------|------------|---------|
      | [Term] | [Definition] | [Context] |

      ## External Resources

      - [Resource 1]: [Description and link]
      - [Resource 2]: [Description and link]

      ## Updated: YYYY-MM-DD
      ```

      ### 5. Vibe-Tools Playbook ([vibe-tools-playbook.md](mdc:docs/memory/vibe-tools-playbook.md))

      Provides comprehensive documentation for vibe-tools commands, options, and usage scenarios. Serves as the primary user guide for vibe-tools integration with the AI-assisted workflow.

      ## AI-Assisted Agile Workflow Rule

      The Memory Management system works in conjunction with the [ai-agile-workflow.mdc](mdc:.cursor/rules/ai-agile-workflow.mdc) rule to provide a comprehensive system for maintaining context and tracking project status. The Agile Workflow rule defines the document structure of the central reference document ([features.md](mdc:docs/features.md)), the task/plan structure, and workflow processes

      ## Knowledge Graph Integration

      Memory files work in concert with the Knowledge Graph (KG), a critical component of the assistant's persistent 'memory', (The KG is maintained by the Memory MCP server) using MCP memory tools like `mcp_memory_search_nodes`, `mcp_memory_create_entities`, etc.) when available:

      1. **Entity Creation**: New entities should be created in the knowledge graph for:
         - Project components
         - User preferences
         - Technical decisions
         - Domain concepts

      2. **Relationship Mapping**: Create relationships between entities to build a connected knowledge network:
         ```
         [Component A] -> depends_on -> [Component B]
         [User] -> prefers -> [Coding Style]
         [Domain Concept] -> relates_to -> [Business Rule]
         ```

      3. **Memory Retrieval Process**:
         1. Check docs/memory/* files for context
         2. Use knowledge graph search (e.g., `mcp_memory_search_nodes`, `mcp_memory_open_nodes`) for broader context, to retrieve relevant entities for the current task, and to load personalization data.
         3. Combine information for comprehensive understanding
         4. Update both memory files and knowledge graph with new information

      4. **Entity Types for Project Context**:
         - `component`: Technical components of the system
         - `preference`: User preferences and settings
         - `concept`: Domain concepts and terminology
         - `decision`: Technical decisions and rationales
         - `workflow`: Development workflows

      ## Memory File Management

      ### Creating or Updating Memory Files

      1. **Structure**: Follow the established templates
         - Use consistent headers and formatting
         - Maintain the same section order across updates
         - Include all required sections for the file type

      2. **Updates**: Follow these critical update protocols
         - **Always search for existing sections before adding new ones**
         - **Merge content into existing sections rather than creating duplicates**
         - **Keep the "## Updated: YYYY-MM-DD" line as the very last line in the file**
         - Use the current date obtained following [date-consistency-enforcer](mdc:.cursor/rules/date-consistency-enforcer.mdc) (prioritize `mcp_time_get_current_time` tool, fallback to `date +%Y-%m-%d`) for the timestamp
         - There should only be ONE "## Updated: YYYY-MM-DD" line per file

      3. **Section Merging Guidelines**:
         - **For lists**: Add new items to the existing list in appropriate order
         - **For tables**: Add new rows to existing tables, don't create duplicate tables
         - **For narrative text**: Update existing paragraphs or add new ones
         - **For code blocks**: Update existing blocks or add new ones with clear comments

      4. **Avoiding Common Errors**:
         - **NEVER add a duplicate section with the same name** - search for existing sections first
         - **NEVER have multiple timestamp lines** - there should be only one "## Updated:" line
         - **NEVER leave the timestamp in the middle of the file** - it must be the very last line
         - **NEVER overwrite existing content** - merge or append appropriately

      5. **References**: Include links to other related memory files
         - Use relative paths (e.g., `/docs/memory/workflow-status.md`)
         - Maintain cross-references between related memory files

      6. **Synchronization**: Keep memory files in sync with the knowledge graph
         - Update both when new information is available
         - Ensure consistency between file content and graph entities

      ### Memory File Update Process

      When updating a memory file, follow this process:

      1. **Read the entire file** first to understand its structure and content
      2. **Identify sections to update** based on new information
      3. **Search for each section name** (using Ctrl+F/Cmd+F) before adding content
      4. **Merge new content into existing sections** rather than creating duplicates
      5. **Add entirely new sections only if they don't already exist**
      6. **Update the timestamp** at the end of the file using today's date
      7. **Review the file** to ensure no duplicate sections were created
      8. **Save the file** only after confirming proper structure

      ### Memory File Structure Maintenance

      To maintain the integrity of memory files:

      ```markdown
      # Correct ✓
      ## Section A
      Content for section A

      ## Section B
      Content for section B

      ## Updated: 2025-05-02
      ```

      ```markdown
      # Incorrect ❌
      ## Section A
      Content for section A

      ## Section B
      Content for section B

      ## Updated: 2025-05-01

      ## Section A
      New content for section A

      ## Updated: 2025-05-02
      ```

      ### Using Memory Files

      At the start of EVERY new conversation or task, you MUST load these essential memory files IN THIS ORDER:

      1. **[workflow-status.md](mdc:docs/memory/workflow-status.md)**: CRITICAL - Provides current state of all active tasks and projects
      2. **[architecture.md](mdc:docs/memory/architecture.md)**: REQUIRED - Contains system architecture and component relationships
      3. **[user-preferences.md](mdc:docs/memory/user-preferences.md)**: REQUIRED - Details preferences for code style, tools, and workflows
      4. **[domain-knowledge.md](mdc:docs/memory/domain-knowledge.md)**: REQUIRED - Contains domain-specific concepts and terminology
      5. **[decisions.md](mdc:docs/memory/decisions.md)**: REQUIRED - Record of key technical decisions

      This context loading is MANDATORY, not optional, to ensure you have sufficient context to follow the [ai-agile-workflow](mdc:.cursor/rules/ai-agile-workflow.mdc) accurately and provide consistent assistance.

      Always use `Sequential Thinking` to thoroughly analyze these files and extract relevant information for the current task or query.

      Additional relevant memory files may be loaded after these essential files based on the specific task or context:

      - **[vibe-tools-playbook.md](mdc:docs/memory/vibe-tools-playbook.md)**: Load when working with vibe-tools commands, automation, or integration tasks

      ## Sequential Thinking for Memory Management
      When managing memory files (reading, updating, or creating), and instructions refer to 'Sequential Thinking', a 'step-by-step approach', or 'structured reasoning', this indicates the use of the **`mcp_sequential-thinking_sequentialthinking`** tool. This tool is essential for thorough analysis, context integration, consistency checking, and ensuring comprehensive updates to memory files.

      When reading, updating, or creating memory files, you MUST use the **`mcp_sequential-thinking_sequentialthinking`** tool to ensure:

      1. **Thorough Analysis**: Carefully examine existing content before making changes
      2. **Context Integration**: Connect new information with existing knowledge
      3. **Consistency Checking**: Verify that updates maintain consistency across all memory files
      4. **Comprehensive Updates**: Ensure all relevant sections are updated appropriately
      5. **Long-term Context Retention**: Preserve important information for future sessions

      For complex memory operations like merging duplicate sections or resolving conflicts, the step-by-step reasoning provided by **`mcp_sequential-thinking_sequentialthinking`** tool is essential for maintaining memory integrity.

      When you see instructions to "Use Sequential Thinking," this means you should either:
      1. Use the `mcp_sequential-thinking_sequentialthinking` tool when available, OR
      2. Structure your response with explicitly numbered thought steps, showing your reasoning process

      ### Knowledge Graph Tools

      When the knowledge graph MCP server is available:

      - `mcp_memory_read_graph`: Get a complete view of the knowledge graph
      - `mcp_memory_search_nodes`: Find specific information in the graph
      - `mcp_memory_open_nodes`: Access specific entity details
      - `mcp_memory_create_entities`: Add new information to the graph (new concepts, items)
      - `mcp_memory_create_relations`: Connect entities meaningfully
      - `mcp_memory_add_observations`: Update existing entities with new facts or details
      - `mcp_memory_delete_entities`: Remove entities from the graph
      - `mcp_memory_delete_observations`: Remove specific observations from an entity
      - `mcp_memory_delete_relations`: Remove relationships between entities
      - **Important:** Before executing any KG modification tools (especially `mcp_memory_create_*`, `mcp_memory_add_observations`, `mcp_memory_delete_*`), the assistant should internally review the tool's parameters and intended effect to ensure accuracy and prevent unintended changes to its persistent memory.

      ## Memory File Updates

      To ensure memory files and the knowledge graph remain up-to-date, perform an update process when triggered by task completion or explicit request. This process leverages the relevant information to enrich the persistent context and should follow the principles outlined in the Memory File Management section above.

      ### Trigger Conditions

      The update process is activated when:

      1. **Task completion is indicated by**:
         - Messages containing: `(?i)(task completed|finished implementing|done with|completed task|task is done|fixed issue|implemented|resolved|finished|done)`
         - Content containing `Status: Completed` in task files.

      2. **Explicit update request**:
         - Messages containing: `(?i)(update memory files|refresh memory files|update memory|synchronize memory files)`

      ### Update Process Overview

      When an update trigger (task completion or explicit request) is detected, you MUST perform the following steps:

      1.  **Extracting Task Information**:
          *   Task type (e.g., Feature Implementation, Bug Fix, Configuration)
          *   Core components affected
          *   Problem solved or objective achieved
          *   Solution implemented

      2.  **Updating Memory Files**:
          *   `docs/memory/workflow-status.md`: Mark the completed task as "Completed" in the Task History table, and update the "Current State" section (following the structural guidelines in the Memory File Management section).
          *   `docs/memory/domain-knowledge.md`: Add new insights, implementation patterns, or technical decisions derived from the task to relevant sections (e.g., "Implementation Patterns", "Technical Decisions") while adhering to the Section Merging Guidelines.
          *   Task-Specific Memory File (Optional): Detailed implementation notes might be added to a dedicated file (e.g., `docs/memory/tasks/YYYY-MM-DD-XX.md`). If creating this file, follow the Creating or Updating Memory Files guidelines and appropriate templates from the `docs/templates/` directory.

      3.  **Updating Knowledge Graph**: *This step is crucial for evolving the assistant's memory.*
          *   Create new entities for new components, concepts, or significant patterns introduced by the task (using `mcp_memory_create_entities`).
          *   Create relationships to link the new entities to existing ones (using `mcp_memory_create_relations`).
          *   Add observations to relevant entities, capturing key details about the implementation or decisions made (using `mcp_memory_add_observations`).

      ### Memory Update Process for Direct User Requests

      > **IMPORTANT: THIS SECTION IS AUTOMATICALLY TRIGGERED WHEN PHRASES LIKE "update memory files", "refresh memory files", "update memory", or "synchronize memory files" ARE DETECTED!**
      >
      > When these trigger phrases are detected, you MUST immediately execute this process to ensure memory files remain updated and consistent across all sessions.

      When directly requested to update memory files (via "update memory files" or similar trigger phrases):

      1. **Assess Update Scope**:
         - **Required Files**: ALWAYS update `workflow-status.md` AND `features.md`
         - **Context**: Review recent updates in workflow-status.md to determine what's changed

      2. **Critical Update Principles**:
         - **Start with Audit Trail**: First add entry to Recent Updates in workflow-status.md
           ```
           "- Updated memory files to reflect current project status. (YYYY-MM-DD)"
           ```
         - **Feature Updates**: ONLY update ACTIVE features identified in workflow-status.md
           - Features must be updated but only those with actual progress since last update
           - Verify active features via "Current Task", "Next Task", and "Recent Updates" in workflow-status.md
           - Never update timestamps for inactive or unchanged features
         - **Timestamps**: Update bottom timestamp on all modified files
         - **Knowledge Graph**: Synchronize memory files with KG via appropriate tools

      3. **Implementation Steps**:
         - Get current date via `mcp_time_get_current_time`
         - Update workflow-status.md first
         - For features.md, follow template at `docs/templates/features-template.md`
         - Apply all Section Merging Guidelines from above
         - Verify consistency across all updated files

      ### Best Practices for Memory File Updates

      ALWAYS adhere to these principles (which align with general memory management best practices):
      1.  **Specificity**: Ensure extracted task information is detailed and accurate.
      2.  **Contextualization**: Document the "why" behind the changes, not just the "what".
      3.  **Connectivity**: Link new knowledge to existing concepts in memory files and the graph.
      4.  **Lessons Learned**: Capture any significant challenges, solutions, or alternatives considered.

      This update process integrates seamlessly with the overall [AI-Assisted Agile Workflow](mdc:.cursor/rules/ai-agile-workflow.mdc) to maintain a continuously improving knowledge base.

examples:
  - input: |
      Can you tell me about the current state of the project?
    output: |
      I'll check the memory files to understand the current project state.

      Based on the [workflow status memory file](/docs/memory/workflow-status.md), here's what I can tell you:

      **Current Project**: Cursor Rules System Improvement
      **Current Phase**: Implementation Phase 1
      **Active Task**: Create a relationship diagram for all rules (Task ID: 2025-04-25-01)
      **Next Task**: Define standard linking format (Task ID: 2025-04-25-02)

      The project is implementing a hierarchical rule structure with cross-references. The goal is to transform rules from independent documents into a navigable, interconnected knowledge system.

      Recent updates include:
      - Moving documentation from reference/ to docs/
      - Renaming "recommendations" to "features" to better align with agile methodology
      - Creating various templates for tasks, plans, and features
      - Setting up the memory management system

      Would you like more specific information about the current task, the overall plan, or another aspect of the project? (Information sourced from [workflow-status.md](/docs/memory/workflow-status.md))

  - input: |
      I need you to memorize this API endpoint for future reference.
    output: |
      To store an API endpoint for future reference, I recommend documenting it in your code, comments, or a dedicated API reference document rather than relying on memory files.

      You could add it to:

      1. Your code as a constant:
      ```typescript
      export const API_ENDPOINT = 'https://api.example.com/v1/resource';
      ```

      2. A dedicated API reference file:
      ```markdown
      # API References

      ## External APIs
      - Example API: `https://api.example.com/v1/resource`
      ```

      3. Environment variables or configuration files.

      This approach keeps API references with your project code rather than in memory management files, which are primarily used for context retention across AI conversations. Would you like me to add this API endpoint to your code or a dedicated API reference file?

metadata:
  priority: high
  version: 2.0.0
  tags:
    - memory
    - context
    - workflow
    - knowledge-graph
    - automation
</rule>
